/ *
 AngularJS v1.7.9
 (c) 2010-2018 Google, Inc. http://angularjs.org
 Licença: MIT
* /
(function (C) {'use strict'; function re (a) {if (D (a)) w (a.objectMaxDepth) && (Wb.objectMaxDepth = Xb (a.objectMaxDepth)? a.objectMaxDepth: NaN), w (a.urlErrorParamsEnabled) && Ga (a.urlErrorParamsEnabled) && (Wb.urlErrorParamsEnabled = a.urlErrorParamsEnabled); caso contrário, retorne Wb} função Xb (a) {retorna W (a) && 0 <a} função F (a, b) { b = b || Erro; função de retorno () {var d = argumentos [0], c; c = "[" + (a? a + ":": "") + d + "] http: //errors.angularjs .org / 1.7.9 / "+ (a? a +" / ":" ") + d; para (d = 1; d <comprimento do argumento; d ++) {c = c + (1 == d?"? " : "&") + "p" + (d-1) + "="; var e = encodeURIComponent,
f; f = argumentos [d]; f = "função" == tipo de f? f.toString (). replace (/ \ {[\ s \ S] * $ /, ""): "indefinido" == tipo de f? "undefined": "string"! = tipo de f? JSON.stringify (f): f; c + = e (f)} retorna nova função b (c)}} ya (a) {if (null == a || $ a (a)) return! 1; if (H (a) || A (a) || x && uma instância de x) return! 0; var b = "length" em Object (a) && a.length; return W (b) && (0 <= b && b-1 em uma || "função" === tipo de a.item)} função r (a, b, d) {var c, e; se (a) se (B (a)) para (c em a) "protótipo"! == c && "comprimento"! == c && "nome"! == c && a.hasOwnProperty (c) && b.call (d, a [c], c, a ); caso contrário, se (H (a) ||
ya (a)) {var f = "objeto"! == tipo de a; c = 0; para (e = comprimento; c <e; c ++) (f || c em a) &&b.call (d, a [c], c, a)} else if (a.forEach && a.forEach! == r) a.forEach (b, d, a); else if (Nc (a)) para (c em a) b. chamar (d, a [c], c, a); caso contrário, se ("função" === tipo de a.hasOwnProperty) para (c em a) a.hasOwnProperty (c) && b.call (d, a [c] , c, a); else for (c em a) ta.call (a, c) && b.call (d, a [c], c, a); retorna a} função Oc (a, b, d) { Para (var c = Object.keys (a) .sort (), e = 0; e <c.length; e ++) b.call (d, a [c [e]], c [e]); return c } função Yb (a) {função de retorno (b, d) {a (d, b)}} função se () {return ++ pb}
função Zb (a, b, d) {for (var c = a. $$ hashKey, e = 0, f = comprimento b; e <f; ++ e) {var g = b [e]; if ( D (g) || B (g)) para (var k = Object.keys (g), h = 0, l = k.length; h <l; h ++) {var m = k [h], p = g [m]; d && D (p)? ha (p)? a [m] = nova data (p.valorOf ()): ab (p)? a [m] = novo RegExp (p): p.nodeName? a [m] = p.cloneNode (! 0): $ b (p)? a [m] = p.clone (): "__ proto __"! == m && (D (a [m]) || (a [ m] = H (p)? []: {}), Zb (a [m], [p] ,! 0)): a [m] = p}} c? a. $$ hashKey = c: delete a. $$ hashKey; retornar a} função S (a) {retornar Zb (a, Ha.call (argumentos, 1) ,! 1)} função te (a) {retornar Zb (a, Ha.call (argumentos, 1) ,! 0)} função fa (a) {return parseInt (a,
10)} função ac (a, b) {retorna S (Object.create (a), b)} função E () {} função Ta (a) {retorna a} função ia (a) {retorna função () { retornar a}} função bc (a) {retornar B (a.toString) && a.toString! == la} função z (a) {retornar "indefinido" === tipo de a} função w (a) {return "indefinido "! == tipo de a} função D (a) {retornar nulo! == a &&" objeto "=== tipo de a} função Nc (a) {retornar nulo! == a &&" objeto "=== tipo de um &&! Pc (a)} função A (a) {return "string" === tipo de a} função W (a) {return "number" === tipo de a} função ha (a) {return "[object Date]" = == la.call (a)}
função H (a) {return Array.isArray (a) || uma instância da Array} função cc (a) {switch (la.call (a)) {case "[object error]": return! 0; case "[ exceção do objeto] ": return! 0; case" [exceção DOM do objeto] ": retorno! 0; padrão: retornar uma instância do erro}} função B (a) {return" function "=== tipo de a} função ab (a) {return "[RegExp de objeto]" === função la.call (a)} função $ a (a) {retorne uma && a.window === a} função bb (a) {retorne uma função && a. $ evalAsync && a. $ watch} Ga (a) {return "boolean" === tipo de a} função ue (a) {retorna a && W (a.length) && ve.test (la.call (a))}
função $ b (a) {return! (! a ||! (a.nodeName || a.prop && a.attr && a.find))} função we (a) {var b = {}; a = a.split (" , "); var d; para (d = 0; d <comprimento.a; d ++) b [a [d]] =! 0; retornar b} função ua (a) {retornar K (a.nodeName || a [0] && a [0] .nodeName)} função cb (a, b) {var d = a.indexOf (b); 0 <= d && a.splice (d, 1); retorno d} função Ia (a, b , d) {função c (a, b, c) {c -; se (0> c) retornar "..."; var d = b. $$ hashKey, f; if (H (a)) { f = 0; para (var g = a.length; f <g; f ++) b.push (e (a [f], c))}} senão se (Nc (a)) for (f em a) b [ f] = e (a [f], c); caso contrário, se (a && "função" === tipo de a.hasOwnProperty) para (f em a) a.hasOwnProperty (f) &&
(b [f] = e (a [f], c)); caso contrário, para (f em a) ta.call (a, f) && (b [f] = e (a [f], c)); d? b. $$ hashKey = d: excluir b. $$ hashKey; retornar b} função e (a, b) {if (! D (a)) retornar a; var d = g.indexOf (a); if (-1! == d) retorna k [d]; if ($ a (a) || bb (a)) lança pa ("cpws"); var d =! 1, e = f (a); void 0 === e && (e = H (a)? []: Object.create (Pc (a)), d =! 0); g.push (a); k.push (e); return d? C (a, e, b): e} função f (a) {switch (la.call (a)) {case "[objeto Int8Array]": caso "[objeto Int16Array]": case "[objeto Int32Array]": case "[objeto Float32Array]": case "[objeto Float64Array]": case "[objeto Uint8Array]": case "[objeto Uint8ClampedArray]": case "[objeto Uint16Array]": case "[objeto Uint32Array]": retornar novo a.constructor (e (a.buffer),
a.byteOffset, a.length); case "[object ArrayBuffer]": if (! a.slice) {var b = new ArrayBuffer (a.byteLength); (new Uint8Array (b)). set (new Uint8Array (a )); return b} retorna a.slice (0); case "[objeto Booleano]": case "[número do objeto]": case "[objeto String]": case "[data do objeto]": retorna novo a. construtor (a.valueOf ()); case "[object RegExp]": return b = new RegExp (a.source, a.toString (). match (/ [^ /] * $ /) [0]), b .lastIndex = a.lastIndex, b; case "[object Blob]": retorna um novo a.constructor ([a], {type: a.type})} if (B (a.cloneNode)) retorna a.cloneNode ( 0)}
var g = [], k = []; d = Xb (d)? d: NaN; if (b) {if (ue (b) || "[objeto ArrayBuffer]" === la.call (b) ) throw pa ("cpta"); if (a === b) throw pa ("cpi"); H (b)? b.length = 0: r (b, função (a, c) {"$$ hashKey "! == c && delete b [c]}); g.push (a); k.push (b); return c (a, b, d)} return e (a, d)} function dc (a, b) {retornar a === b || a! == a && b! == b} função va (a, b) {if (a === b) retornar! 0; if (null === a || null === b) return! 1; if (a! == a && b! == b) return! 0; var d = tipo de a, c; if (d === tipo de b && "objeto" === d) if (H (a)) {if (! H (b)) return! 1; if ((d = a.length) === b.length) {for (c = 0; c <d; c ++) se (! va (a [c],
b [c])) return! 1; return! 0}} else {if (ha (a)) return ha (b)? dc (a.getTime (), b.getTime ()) :! 1; if ( ab (a)) return ab (b)? a.toString () === b.toString () :! 1; if (bb (a) || bb (b) || $ a (a) || $ a (b) || H (b) || ha (b) || ab (b)) return! 1; d = T (); para (c em a) if ("$"! == c.charAt (0) &&! B (a [c])) {if (! Va (a [c], b [c])) retorna! 1; d [c] =! 0} para (c em b) se ( ! (c em d) && "$"! == c.charAt (0) &&w (b [c]) &&! B (b [c])) return! 1; return! 0} return! 1} função db (a, b, d) {retorna a.concat (Ha.call (b, d))} função Va (a, b) {var d = 2 <argumentos.length? Ha.call (argumentos, 2): [ ]; return! B (b) || b instanceof
RegExp? B: d.length? Function () {return argumentos.length? B.apply (a, db (d, argumentos, 0)): b.apply (a, d)}: function () {return argumentos. comprimento? b.apply (a, argumentos): b.call (a)}} função Qc (a, b) {var d = b; "string" === tipo de a && "$" === a.charAt ( 0) && "$" === a.charAt (1)? D = void 0: $ a (b)? D = "$ WINDOW": b && C.document === b? D = "$ DOCUMENT": bb (b) && (d = "$ SCOPE"); return d} função eb (a, b) {if (! z (a)) retorna W (b) || (b = b? 2: null), JSON .stringify (a, Qc, b)} função Rc (a) {retornar A (a)? JSON.parse (a): a} função ec (a, b) {a = a.replace (xe, "") ; var d = Date.parse ("01 de janeiro de 1970 00:00:00" +
a) / 6E4; return X (d)? b: d} função Sc (a, b) {a = new Date (a.getTime ()); a.setMinutes (a.getMinutes () + b); retorna a } função fc (a, b, d) {d = d? -1: 1; var c = a.getTimezoneOffset (); b = ec (b, c); retorna Sc (a, d * (bc))} função za (a) {a = x (a) .clone (). empty (); var b = x ("<div> </div>") .append (a) .html (); tente {retornar um [0] .nodeType === Pa? K (b): b.match (/ ^ (<[^>] +>) /) [1]. Substitua (/ ^ <([\ w -] +) / , function (a, b) {return "<" + K (b)})} catch (d) {return K (b)}} function Tc (a) {try {return decodeURIComponent (a)} catch (b) {}} função gc (a) {var b = {}; r ((a || ""). split ("&"),
função (a) {var c, e, f; a && (e = a = a.replace (/ \ + / g, "% 20"), c = a.indexOf ("="), - 1! == c && (e = a.substring (0, c), f = a.substring (c + 1)), e = Tc (e), w (e) && (f = w (f)? Tc (f): ! 0, ta.call (b, e)? H (b [e])? B [e] .push (f): b [e] = [b [e], f]: b [e] = f ))}); return b} função ye (a) {var b = []; r (a, função (a, c) {H (a)? r (a, função (a) {b.push (ba (c,! 0) + (! 0 === a? "": "=" + ba (a,! 0)))}): b.push (ba (c,! 0) + (! 0 = == a? "": "=" + ba (a,! 0)))}); return b.length? b.join ("&"): ""} função hc (a) {return ba (a ,! 0) .replace (/% 26 / gi, "&"). Replace (/% 3D / gi, "="). Replace (/% 2B / gi, "+")} função ba (a,
b) {return encodeURIComponent (a) .replace (/% 40 / gi, "@"). replace (/% 3A / gi, ":"). replace (/% 24 / g, "$"). replace ( /%2C/gi,",").replace(/%3B/gi,";").replace(/%20/g,b?"%20":"+")}função ze (a, b ) {var d, c, e = Qa.length; for (c = 0; c <e; ++ c) if (d = Qa [c] + b, A (d = a.getAttribute (d))) return d; return null} função Ae (a, b) {var d, c, e = {}; r (Qa, função (b) {b + = "app";! d && a.hasAttribute && a.hasAttribute (b) && ( d = a, c = a.getAttribute (b))}); r (Qa, função (b) {b + = "app"; var e;! d && (e = a.querySelector ("[" + b.replace (":", "\\:") + "]")) && (d = e, c = e.getAttribute (b))});
d && (Be? (e.strictDi = null! == ze (d, "strict-di"), b (d, c? [c]: [], e)): C.console.error ("AngularJS: desativando a autoinicialização automática. o protocolo <script> indica uma extensão, document.location.href não corresponde. "))} função Uc (a, b, d) {D (d) || (d = {}); d = S ({strictDi:! 1}, d); var c = função () {a = x (a); if (a.injector ()) {var c = a [0] === C.documento? " documento ": za (a); throw pa (" btstrpd ", c.replace (/ </," & lt; "). replace (/> /," & gt; "));} b = b || [] ; b.unshift (["$ fornecer", função (b) {b.valor ("$ rootElement", a)}]); d.debugInfoEnabled && b.push (["$ compileProvider",
função (a) {a.debugInfoEnabled (! 0)}]); b.unshift ("ng"); c = fb (b, d.strictDi); c.invoke (["$ rootScope", "$ rootElement" , "$ compile", "$ injector", função (a, b, c, d) {a. $ apply (function () {b.data ("$ injector", d); c (b) (a) })}]); return c}, e = / ^ NG_ENABLE_DEBUG_INFO! /, f = / ^ NG_DEFER_BOOTSTRAP! /; C && e.test (C.name) && (d.debugInfoEnabled =! 0, C.name = C.name .replace (e, "")); if (C &&! f.test (C.name)) retorna c (); C.name = C.name.replace (f, ""); ca.resumeBootstrap = function ( a) {r (a, function (a) {b.push (a)}); return c ()}; B (ca.resumeDeferredBootstrap) &&
função ca.resumeDeferredBootstrap ()} função Ce () {C.name = "NG_ENABLE_DEBUG_INFO!" + C.name; C.location.reload ()} função De (a) {a = ca.element (a) .injector () ; if (! a) joga pa ("teste"); retorna a.get ("$$ testability")} função Vc (a, b) {b = b || "_"; retorna a.replace (Ee, função (a, c) {return (c? b: "") + a.toLowerCase ()})} função Fe () {var a; if (! Wc) {var b = qb (); (rb = z (b)? C.jQuery: b? C [b]: void 0) && rb.fn.on? (x = rb, S (rb.fn, {escopo: Wa.scope, isolateScope: Wa.isolateScope, controlador: Wa.controller, injector: Wa.injector, herdatedData: Wa.inheritedData})):
x = Y; a = x.cleanData; x.cleanData = function (b) {for (var c, e = 0, f; null! = (f = b [e]); e ++) (c = (x. _data (f) || {}). events) && c. $ destroy && x (f) .triggerHandler ("$ destroy"); a (b)}; ca.element = x; Wc =! 0}} função gb (a , b, d) {if (! a) joga pa ("areq", b || "?", d || "obrigatório"); retorna a} função sb (a, b, d) {d && H (a) && (a = a [a.length-1]); gb (B (a), b, "não é uma função, obteve" + (a && "object" === tipo de a? a.constructor.name || " Objeto ": tipo de a)); retornar a} função Ja (a, b) {if (" hasOwnProperty "=== a) throw pa (" badname ", b);} função Ge (a, b, d) { se (! b) retornar a; b = b.split (".");
Para (var c, e = a, f = comprimento b, g = 0; g <f; g ++) c = b [g], a && (a = (e = a) [c]); return! d && B ( a) Va (e, a): a} função tb (a) {for (var b = a [0], d = a [a.length-1], c, e = 1; b! == d && (b = b.nextSibling); e ++) if (c || a [e]! == b) c || (c = x (Ha.call (a, 0, e))), c.push (b ); return c || a} função T () {return Object.create (null)} função ic (a) {if (null == a) return ""; switch (typeof a) {case "string": break ; case "number": a = "" + a; break; default: a =! bc (a) || H (a) || ha (a)? eb (a): a.toString ()} retorna um } function He (a) {function b (a, b, c) {return a [b] || (a [b] = c ())} var d = F ("$ injector"),
c = F ("ng"); a = b (a, "angular", Object); a. $$ minErr = a. $$ minErr || F; retorna b (a, "módulo", função () { var a = {}; função de retorno (f, g, k) {var h = {}; if ("hasOwnProperty" === f) lança c ("badname", "module"); g && a.hasOwnProperty (f) && (a [f] = null); return b (a, f, function () {function a (b, c, d, f) {f || (f = e); return function () {f [d || "push"] ([b, c, argumentos]); retorno t}} função b (a, c, d) {d || (d = e); função de retorno (b, e) {e && B (e ) && (e. $$ moduleName = f); d.push ([a, c, argumentos]); return t}} if (! g) throw d ("nomod", f); var e = [], n = [], s = [], G = a ("$ injector", "invoke",
"push", n), t = {_ invokeQueue: e, _configBlocks: n, _runBlocks: s, info: function (a) {if (w (a)) {if (! D (a)) throw c ("aobj "," valor "); h = a; retorne isso} retorne h}, requer: g, nome: f, provedor: b (" $ fornece "," provedor "), fábrica: b (" $ fornece "," fábrica "), serviço: b (" $ fornecer "," serviço "), valor: a (" $ fornecer "," valor "), constante: a (" $ fornecer "," constante "," não mudar "), decorator: b ("$ allow", "decorator", n), animação: b ("$ animateProvider", "register"), filtro: b ("$ filterProvider", "register"), controlador: b ("$ controllerProvider "," register "), diretiva: b (" $ compileProvider ",
"directiva"), componente: b ("$ compileProvider", "componente"), config: G, run: function (a) {s.push (a); devolve}}; k && G (k); return t} )}})} function ja (a, b) {if (H (a)) {b = b || []; for (var d = 0, c = comprimento.a; d <c; d ++) b [ d] = a [d]} senão se (D (a)) para (d em b = b || {}, a) if ("$"! == d.charAt (0) || "$"! == d.charAt (1)) b [d] = a [d]; retorna b || a} função Ie (a, b) {var d = []; Xb (b) && (a = ca.copy (a, null, b)); retorna JSON.stringify (a, function (a, b) {b = Qc (a, b); if (D (b)) {if (0 <= d.indexOf (b )) return "..."; d.push (b)} return b})} function Je (a) {S (a, {errorHandlingConfig: re,
bootstrap: Uc, copiar: Ia, estender: S, mesclar: te, é igual a: va, elemento: x, forEach: r, injector: fb, noop: E, bind: Va, toJson: eb, fromJson: Rc, identity: Ta, isUndefined: z, isDefined: w, isString: A, isFunction: B, isObject: D, isNumber: W, isElement: $ b, isArray: H, versão: Ke, isDate: ha, retornos de chamada: {$$ counter: 0}, getTestability: De, reloadWithDebugInfo: Ce, $$ minErr: F, $$ csp: Aa, $$ encodeUriSegment: hc, $$ encodeUriQuery: ba, $$ minúsculo: K, $$ stringify: ic, $$ uppercase : ub}); kc = He (C); kc ("ng", ["ngLocale"], ["$ fornecer", função (a) {a.provider ({$$ sanitizeUri: Le});
a.provider ("$ compile", Xc) .directive ({a: Me, input: Yc, textarea: Yc, formulário: Ne, script: Oe, select: Pe, opção: Qe, ngBind: Re, ngBindHtml: Se , ngBindTemplate: Te, ngClass: Ue, ngClassEven: Ve, ngClassOdd: We, ngCloak: Xe, ngController: Ye, ngForm: Ze, ngHide: $ e, ngIf: af, ngInclude: bf, ngInit: cf, ngNonBindable: df, ngPluralize: ef, ngRef: ff, ngRepeat: gf, ngShow: hf, ngStyle: jf, ngSwitch: kf, ngSwitchWhen: lf, ngSwitchDefault: mf, ngOptions: nf, ngTransclude: of, ngModel: pf, ngList: qf, ngChange: rf, padrão: Zc, ngPattern: Zc, necessário: $ c, ngRequired: $ c, minlength: ad,
ngMinlength: ad, maxlength: bd, ngMaxlength: bd, ngValue: sf, ngModelOptions: tf}). Directive ({ngInclude: uf, input: vf}) .Directive (vb) .directive (cd); a.provider ({ $ anchorScroll: wf, $ animate: xf, $ animateCss: yf, $$ animateJs: zf, $$ animateQueue: Af, $$ AnimateRunner: Bf, $$ animateAsyncRun: Cf, $ navegador: Df, $ cacheFactory: Ef, $ controller: Ff, $ document: Gf, $$ isDocumentHidden: Hf, $ exceptionHandler: If, $ filter: dd, $$ forceReflow: Jf, $ interpolate: Kf, $ intervalo: Lf, $$ intervalo: Lf, $$ intervalFactory: Mf, $ http: Nf, $ httpParamSerializer: Of, $ httpParamSerializerJQLike: Pf,
$ httpBackend: Qf, $ xhrFactory: Rf, $ jsonpCallbacks: Sf, $ location: Tf, $ log: Uf, $ parse: Vf, $ rootScope: Wf, $ q: Xf, $$ q: Yf, $ sce: Zf , $ sceDelegate: $ f, $ sniffer: ag, $$ taskTrackerFactory: bg, $ templateCache: cg, $ templateRequest: dg, $$ testabilidade: por exemplo, $ timeout: fg, $ window: gg, $$ rAF: hg, $$ jqLite: ig, $$ Mapa: jg, $$ cookieReader: kg})}]). info ({angularVersion: "1.7.9"})} função wb (a, b) {return b.toUpperCase () } função xb (a) {retornar a.replace (lg, wb)} função lc (a) {a = a.nodeType; retornar 1 === a ||! a || 9 === a} função ed ( a, b) {var d, c, e = b.createDocumentFragment (),
f = []; if (mc.test (a)) {d = e.appendChild (b.createElement ("div")); c = (mg.exec (a) || ["", ""]) [1] .toLowerCase (); c = oa [c] || oa._default; d.innerHTML = c [1] + a.replace (ng, "<$ 1> </ $ 2>") + c [2] ; para (c = c [0]; c -;) d = d.lastChild; f = db (f, d.childNodes); d = e.firstChild; d.textContent = ""} else f.push ( b.createTextNode (a)); e.textContent = ""; e.innerHTML = ""; r (f, função (a) {e.appendChild (a)}); retorne e} função Y (a) {se (uma instância de Y) retorna a; var b; A (a) && (a = U (a), b =! 0); if (! (essa instância de Y)) {if (b && "<"! == a .charAt (0)) joga nc ("nosel"); retorna novo Y (a)} se (b) {b =
C.document; var d; a = (d = og.exec (a))? [B.createElement (d [1])] :( d = ed (a, b))? D.childNodes: []; oc (isso, a)} else B (a)? fd (a): oc (isso, a)} função pc (a) {retorna a.cloneNode (! 0)} função yb (a, b) {! b && lc (a) && x.cleanData ([a]); a.querySelectorAll && x.cleanData (a.querySelectorAll ("*"))} função gd (a) {for (var b em a) return! 1; return! 0} function hd (a) {var b = a.ng339, d = b && Ka [b], c = d && d.events, d = d && d.data; d &&! gd (d) || c &&! gd (c) || ​​(excluir Ka [b], a.ng339 = 0 nulo)} ID da função (a, b, d, c) {if (w (c)) lança nc ("offargs"); var e = (c = zb (a)) && c.events,
f = c && c.handle; if (f) {if (b) {var g = função (b) {var c = e [b]; w (d) && cb (c || [], d); w (d ) && c && 0 <c.length || (a.removeEventListener (b, f), delete e [b])}; r (b.split (""), função (a) {g (a); Ab [a] && g (Ab [a])})} mais para (b em e) "$ destroy"! == b && a.removeEventListener (b, f), exclua e [b]; hd (a)}} função qc (a, b) {var d = a.ng339; if (d = d && Ka [d]) b? delete d.data [b]: d.data = {}, hd (a)} função zb (a, b) {var d = a.ng339, d = d && Ka [d]; b &&! d && (a.ng339 = d = ++ pg, d = Ka [d] = {eventos: {}, dados: {}, identificador: void 0} ); return d} função rc (a, b, d) {if (lc (a)) {var c, e = w (d),
f =! e && b &&! D (b), g =! b; a = (a = zb (a,! f)) && a.data; if (e) a [xb (b)] = d; else {if ( g) retorna a; se (f) retorna a && a [xb (b)]; para (c em b) a [xb (c)] = b [c]}}} função Bb (a, b) {retorna a. getAttribute? -1 <("" + (a.getAttribute ("class") || "") + ""). substitua (/ [\ n \ t] / g, "") .indexOf ("" + b + "") :! 1} função Cb (a, b) {if (b && a.setAttribute) {var d = ("" + (a.getAttribute ("classe") || "") + "")) ".placeplace ( / [\ n \ t] / g, ""), c = d; r (b.split ("")), função (a) {a = U (a); c = c.replace ("" + a + "", "")}); c! == d && a.setAttribute ("classe", U (c))}} função Db (a, b) {if (b && a.setAttribute) {var d =
("" + (a.getAttribute ("class") || "") + ""). substituir (/ [\ n \ t] / g, ""), c = d; r (b.split (" "), function (a) {a = U (a); - 1 === c.indexOf (" "+ a +" ") && (c + = a +" ")}); c! == d && a.setAttribute ( "classe", U (c))}} função oc (a, b) {se (b) se (b.nodeType) a [a.length ++] = b; caso contrário {var d = b.length; if (" número "=== tipo de d && b.window! == b) {if (d) for (var c = 0; c <d; c ++) a [a.length ++] = b [c]} mais a [a.length ++ ] = b}} função jd (a, b) {retorna Eb (a, "$" + (b || "ngController") + "Controller")} função Eb (a, b, d) {9 === a.nodeType && (a = a.documentElement); for (b = H (b)? b: [b]; a;) {for (var c =
0, e = b.length; c <e; c ++) if (w (d = x.dados (a, b [c])))) retorna d; a = a.parentNode || 11 === a.nodeType && a .host}} função kd (a) {for (yb (a,! 0); a.firstChild;) a.removeChild (a.firstChild)} função Fb (a, b) {b || yb (a); var d = a.parentNode; d && d.removeChild (a)} função qg (a, b) {b = b || C; if ("complete" === b.document.readyState) b.setTimeout (a); else x (b) .on ("carga", a)} função fd (a) {função b () {C.document.removeEventListener ("DOMContentLoaded", b); C.removeEventListener ("carga", b); a ()} "complete" === C.document.readyState? C.setTimeout (a) :( C.document.addEventListener ("DOMContentLoaded",
b), C.addEventListener ("carga", b))} função ld (a, b) {var d = Gb [b.toLowerCase ()]; retorna d && md [ua (a)] && d} função rg (a, b) {var d = função (c, d) {c.isDefaultPrevented = function () {retornar c.defaultPrevented}; var f = b [d || c.type], g = f? f.length: 0; if (g) {if (z (c.immediatePropagationStopped)) {var k = c.stopImmediatePropagation; c.stopImmediatePropagation = function () {c.immediatePropagationStopped =! 0; c.stopPropagation && c.stopPropagation (); k & c c.isImmediatePropagationStopped = function () {return! 0 === c.immediatePropagationStopped};
var h = f.specialHandlerWrapper || sg; 1 <g && (f = ja (f)); para (var l = 0; l <g; l ++) c.isImmediatePropagationStopped () || h (a, c, f [ l])}}; d.elem = a; retornar d} função sg (a, b, d) {d.call (a, b)} função tg (a, b, d) {var c = b.relatedTarget ; c && (c === a || ug.call (a, c)) || d.call (a, b)} função ig () {this. $ get = function () {return S (Y, { hasClass: function (a, b) {a.attr && (a = a [0]); return Bb (a, b)}, addClass: function (a, b) {a.attr && (a = a [0]) ; return Db (a, b)}, removeClass: function (a, b) {a.attr && (a = a [0]); return Cb (a, b)}})}} function La (a, b) {var d = a && a. $$ hashKey;
se (d) retornar "função" === tipo de d && (d = a. $$ hashKey ()), d; d = tipo de a; retornar d = "função" === d || "objeto" === d && null! == a? a. $$ hashKey = d + ":" + (b || se) (): d + ":" + a} função nd () {this._keys = []; this._values ​​= [ ]; this._lastKey = NaN; this._lastIndex = -1} função od (a) {a = Function.prototype.toString.call (a) .place (vg, ""); return a.match (wg) | | a.match (xg)} função yg (a) {return (a = od (a))? "function (" + (a [1] || ""). replace (/ [\ s \ r \ n ] + /, "") + ")": "fn"} função fb (a, b) {função d (a) {função de retorno (b, c) {if (D (b)) r (b, Yb (a)); caso contrário, retorne a (b,
c)}} função c (a, b) {Ja (a, "serviço"); if (B (b) || H (b)) b = n.instantiate (b); if (! b. $ get ) lança Ba ("pget", a); retorna p [a + "Provedor"] = b} função e (a, b) {retorna função () {var c = t.invoke (b, this); if (z (c)) lança Ba ("undef", a); retorna c}} função f (a, b, d) {retorna c (a, {$ get:! 1! == d? e (a, b) : b})} função g (a) {gb (z (a) || H (a), "modulesToLoad", "não uma matriz"); var b = [], c; r (a, função (a ) {função d (a) {var b, c; b = 0; for (c = a.length; b <c; b ++) {var e = a [b], f = n.get (e [0] ); f [e [1]]. apply (f, e [2])}} if (! m.get (a)) {m.set (a,! 0); tente {A (a)? ( c = kc (a)
t.modules [a] = c, b = b.concat (g (c.requires)). concat (c._runBlocks), d (c._invokeQueue), d (c._configBlocks)): B (a)? b.push (n.invoke (a)): H (a)? b.push (n.invoke (a)): sb (a, "módulo")} catch (e) {throw H (a) && ( a = a [a.length-1]), e.message && e.stack && - 1 === e.stack.indexOf (e.message) && (e = e.message + "\ n" + e.stack), Ba ("modulerr", a, e.stack || e.message || e);}}}); retornar b} função k (a, c) {função d (b, e) {if (a.hasOwnProperty ( b)) {if (a [b] === h) lance Ba ("cdep", b + "<-" + l.join ("<-")); retorne a [b]} tente {return l. Desvio (b), a [b] = h, a [b] = c (b, e),
a [b]} catch (f) {lança a [b] === h && exclui a [b], f;} finalmente {l.shift ()}} função e (a, c, f) {var g = [ ]; a = fb. $$ anotação (a, b, f); para (var h = 0, k = comprimento.a; h <k; h ++) {var l = a [h]; if ("string" ! == tipo de l) throw Ba ("itkn", l); g.push (c && c.hasOwnProperty (l)? c [l]: d (l, f))} retorno g} retorno {invoque: function (a , b, c, d) {"string" === tipo de c && (d = c, c = nulo); c = e (a, c, d); H (a) && (a = a [a.length -1]); d = a; if (Ca || "função"! == tipo de d) d =! 1; else {var f = d. $$ ngIsClass; Ga (f) || (f = d. $$ ngIsClass = / ^ classe \ b / .test (Function.prototype.toString.call (d))); d = f} retornar d?
(c.unshift (null), new (Function.prototype.bind.apply (a, c))): a.apply (b, c)}, instanciar: function (a, b, c) {var d = H (a)? a [a.length-1]: a; a = e (a, b, c); a.unshift (null); retorne novo (Function.prototype.bind.apply (d, a))} , get: d, anote: fb. $$ anote, tem: function (b) {return p.hasOwnProperty (b + "Provedor") || a.hasOwnProperty (b)}}} b =! 0 === b; var h = {}, l = [], m = nova Hb, p = {$ fornecer: {provedor: d (c), fábrica: d (f), serviço: d (função (a, b) {return f (a, ["$ injector", function (a) {return a.instantiate (b)}])}), valor: d (function (a, b) {return f (a,
ia (b), 1)}), constante: d (função (a, b) {Ja (a, "constante"); p [a] = b; s [a] = b}), decorador: função (a, b) {var c = n.get (a + "Provedor"), d = c. $ get; c. $ get = function () {var a = t.invoke (d, c); return t. invoque (b, null, {$ delegate: a})}}}}, n = p. $ injector = k (p, função (a, b) {ca.isString (b) && l.push (b); throw Ba ("impr", l.join ("<-"));}), s = {}, G = k (s, função (a, b) {var c = n.get (a + "Provedor", b); return t.invoke (c. $ get, c, void 0, a)}), t = G; p. $ injectorProvider = {$ get: ia (G)}; t.modules = n.modules = T (); var N = g (a), t = G.get ("$ injector"); t.strictDi = b; r (N,
função (a) {a && t.invoke (a)}); t.loadNewModules = function (a) {r (g (a), function (a) {a && t.invoke (a)})}; return t} function wf () {var a =! 0; this.disableAutoScrolling = function () {a =! 1}; this. $ get = ["$ window", "$ location", "$ rootScope", função (b, d, c) {function e (a) {var b = null; Array.prototype.some.call (a, function (a) {if ("a" === ua (a)) retorna b = a,! 0} (); return b} função f (a) {if (a) {a.scrollIntoView (); var c; c = g.yOffset; B (c)? c = c (): $ b (c)? (c = c [0], c = "corrigido"! == b.getComputedStyle (c) .position? 0: c.getBoundingClientRect (). bottom): W (c) ||
(c = 0); c && (a = a.getBoundingClientRect (). top, b.scrollBy (0, ac))} else b.scrollTo (0,0)} função g (a) {a = A (a) Se a resposta ajudou de alguma forma, por favor, marque como resposta, caso a sua dúvida não tenha sido solucionada, por favor, poste novamente. a)))? f (b): "top" === a && f (null): f (null)} var k = b.document; a && c. $ watch (function () {return d.hash ()}, function (a, b) {a === b && "" === a || qg (function () {c. $ evalAsync (g)})}); retorne g}]} função hb (a, b) {if (! a &&! b) return ""; if (! a) return b; if (! b) retorne a; H (a) && (a = a.join ("")); H (b) && (b = b.join ("")); retorne a + "" + b} função zg (a) {A (a) &&
(a = a.split ("")); var b = T (); r (a, função (a) {a.length && (b [a] =! 0)}); return b} função ra (a ) {return D (a)? a: {}} função Ag (a, b, d, c, e) {função f () {qa = null; k ()} função g () {t = y () ; t = z (t)? null: t; va (t, P) && (t = P); N = P = t} função k () {var a = N; g (); if (v! = = h.url () || a! == t) v = h.url (), N = t, r (J, função (a) {a (h.url (), t)})} var h = isto, l = localização, m = história, p = a.setTimeout, n = a.clearTimeout, s = {}, G = e (d); h.isMock =! 1; h. $$ completeOutstandingRequest = G.completeTask; h. $$ incOutstandingRequestCount = G.incTaskCount; h.notifyWhenNoOutstandingRequests =
G.notifyWhenNoPendingTasks; var t, N, v = l.href, jc = b.find ("base"), qa = nulo, y = c.history? Function () {try {return m.state} catch (a ) {}}: E; g (); h.url = function (b, d, e) {z (e) && (e = null); l! == a.location && (l = a.location); m! == a.history && (m = a.history); if (b) {var f = N === e; b = ga (b) .href; if (v === b && (! c.history || f)) return h; var k = v && Da (v) === Da (b); v = b; N = e;! c.history || k && f? (k || (qa = b), d Substitua (b): k? (d = l, e = b, f = e.indexOf ("#"), e = -1 === f? "": e.substr (f), d .hash = e): l.href = b, l.href! == b && (qa = b)) :( m [d? "replaceState": "pushState"] (e, "", b), g ( ));
qa && (qa = b); return h} return (qa || l.href) .replace (/ # $ /, "")}; h.state = function () {return t}; var J = [], I =! 1, P = null; h.onUrlChange = function (b) {if (! I) {if (c.history) x (a) .on ("popstate", f); x (a) .on ("hashchange", f); I =! 0} J.push (b); return b}; h. $$ applicationDestroyed = function () {x (a) .off ("hashchange popstate", f)}; h. $$ checkUrlChange = k; h.baseHref = function () {var a = jc.attr ("href"); retorna um? a.replace (/ ^ (https?:)? \ / \ / [^ / ] * /, ""): ""}; h.defer = function (a, b, c) {var d; b = b || 0; c = c || G.DEFAULT_TASK_TYPE; G.incTaskCount (c) ; d = p (função () {delete s [d];
G.completeTask (a, c)}, b); s [d] = c; retorno d}; h.defer.cancel = function (a) {if (s.hasOwnProperty (a)) {var b = s [ a]; delete s [a]; n (a); G.completeTask (E, b); return! 0} return! 1}} função Df () {this. $ get = ["$ window", "$ log "," $ sniffer "," $ document "," $$ taskTrackerFactory ", função (a, b, d, c, e) {retornar nova função Ag (a, c, b, d, e)}]} função Ef () {this. $ Get = function () {função a (a, c) {função e (a) {a! == p && (n? N === a && (n = an): n = a, f (an, ap), f (a, p), p = a, pn = nulo)} função f (a, b) {a! == b && (a && (ap = b), b && (bn = a) )} if (a em b) jogue F ("$ cacheFactory") ("iid",
a); var g = 0, k = S ({}, c, {id: a}), h = T (), l = c && c.capacity || Número.MAX_VALUE, m = T (), p = nulo , n = nulo; return b [a] = {put: function (a, b) {if (! z (b)) {if (l <Number.MAX_VALUE) {var c = m [a] || (m [a] = {chave: a}); e (c)} a em h || g ++; h [a] = b; g> l && this.remove (n.key); return b}}, get: function ( a) {if (l <Number.MAX_VALUE) {var b = m [a]; if (! b) return; e (b)} return h [a]}, remova: function (a) {if (l < Number.MAX_VALUE) {var b = m [a]; if (! B) return; b === p && (p = bp); b === n && (n = bn); f (bn, bp); delete m [a]} a em h && (excluir h [a], g -)}, removeAll: function () {h = T (); g = 0; m = T ();
p = n = nulo}, destrua: function () {m = k = h = null; exclua b [a]}, info: function () {retorne S ({}, k, {size: g})}} } var b = {}; a.info = function () {var a = {}; r (b, função (b, e) {a [e] = b.info ()}); retorna a}; a .get = function (a) {return b [a]}; return a}} function cg () {this. $ get = ["$ cacheFactory", function (a) {return a ("templates")}]} função Xc (a, b) {função d (a, b, c) {var d = / ^ ([@ &] | [= <] (\ *?)) (\ ??) \ s * ([\ w $] *) $ /, e = T (); r (a, função (a, f) {a = a.trim (); if (a em p) e [f] = p [a]; {var g = a.match (d); if (! g) throw $ ("iscp", b, f, a, c? "definição de ligações do controlador":
"isolar definição do escopo"); e [f] = {mode: g [1] [0], coleção: "*" === g [2], opcional: "?" === g [3], attrName : g [4] || f}; g [4] && (p [a] = e [f])}}); retorne e} função c (a) {var b = a.charAt (0); se (! b || b! == K (b)) lança $ ("baddir", a); if (a! == a.trim ()) lança $ ("baddir", a);} function e ( a) {var b = a.require || a.controller && a.name;! H (b) && D (b) && r (b, função (a, c) {var d = a.match (l); a.substring (d [0] .length) || (b [c] = d [0] + c)}); return b} var f = {}, g = / ^ \ s * diretiva: \ s * ([\ w -] +) \ s + (. *) $ /, k = / (([\ w -] +) (? :: ([^;] +))?;?) /, h = nós ("ngSrc , ngSrcset, src, srcset "),
l = / ^ (?: (\ ^ \ ^?)? (\?)? (\ ^ \ ^?)?)? /, m = / ^ (em [az] + | formação) $ /, p = T (); this.diretiva = função qa (b, d) {gb (b, "nome"); Ja (b, "diretiva"); A (b)? (C (b), gb (d, " DirectiveFactory "), f.hasOwnProperty (b) || (f [b] = [], a.factory (b +" Diretiva ", [" $ injector "," $ exceptionHandler ", função (a, c) {var d = []; r (f [b], função (f, g) {try {var h = a.invoke (f); B (h)? h = {compile: ia (h)} :! h.compile && h .link && (h.compile = ia (h.link)); h.priority = h.priority || 0; h.index = g; h.name = h.name || b; h.require = e (h ); var k = h, l = h.restrict; if (l && (! A (l) ||! / [EACM] /. test (l))) throw $ ("badrestrict",
l, b); k.restrict = l || "EA"; h. $$ moduleName = f. $$ moduleName; d.push (h)} catch (m) {c (m)}}); return d }])), f [b] .push (d)): r (b, Yb (qa)); retorne isso}; this.component = function y (a, b) {function c (a) {function e (b) {retornar B (b) || H (b)? função (c, d) {retornar a.invoke (b, este, {$ elemento: c, $ attrs: d})}: b} var f = b.template || b.templateUrl? b.template: "", g = {controller: d, controllerAs: Bg (b.controller) || b.controllerAs || "$ ctrl", template: e (f) , templateUrl: e (b.templateUrl), transclude: b.transclude, escopo: {}, bindToController: b.bindings || {}, restrito: "E",
requer: b.require}; r (b, função (a, b) {"$" === b.charAt (0) && (g [b] = a)}); retorne g} if (! A ( a)) return r (a, Yb (Va (this, y))), this; var d = b.controller || function () {}; r (b, function (a, b) {"$" = == b.charAt (0) && (c [b] = a, B (d) && (d [b] = a))}); c. $ inject = ["$ injector"]; retorne this.directive (a, c)}; this.aHrefSanitizationWhitelist = function (a) {return w (a)? (b.aHrefSanitizationWhitelist (a), this): b.aHrefSanitizationWhitelist ()}; this.imgSrcSanitizationWhitelist = function (a) {return w (a)? (b.imgSrcSanitizationWhitelist (a), isto): b.imgSrcSanitizationWhitelist ()};
var n =! 0; this.debugInfoEnabled = function (a) {return w (a)? (n = a, this): n}; var s =! 1; this.strictComponentBindingsEnabled = function (a) {return w ( a)? (s = a, this): s}; var G = 10; this.onChangesTtl = function (a) {return argumentos.length? (G = a, this): G}; var t =! 0; this.commentDirectivesEnabled = function (a) {return argument.length? (t = a, this): t}; var N =! 0; this.cssClassDirectivesEnabled = function (a) {return argument.length? (N = a, this): N}; var v = T (); this.addPropertySecurityContext = function (a, b, c) {var d = a.toLowerCase () + "|" + b.toLowerCase ();
if (d em v && v [d]! == c) lança $ ("ctxoverride", a, b, v [d], c); v [d] = c; retorna isso}; (function () {function a (b, c) {r (c, função (a) {v [a.toLowerCase ()] = b})} a (V.HTML, ["iframe | srcdoc", "* | innerHTML", "* | outerHTML "]); a (V.CSS, [" * | style "]); a (V.URL," area | href area | ping a | href a | ping blockquote | citar corpo | fundo del | citar entrada | src ins | citar q | citar ".split (" ")); a (V.MEDIA_URL," audio | src img | src img | srcset source | src source | src source | srcset track | src video | src video | poster ".split ; | objeto da base de código | script de dados | src ".split (" "))}) ();
$ get = ["$ injector", "$ interpolate", "$ exceptionHandler", "$ templateRequest", "$ parse", "$ controller", "$ rootScope", "$ sce", "$ animate" , function (a, b, c, e, p, M, L, u, R) {function q () {try {if (! - Ja) lança Ua = void 0, $ ("infchng", G) ; $ $ Apply (function () {for (var a = 0, b = Ua.length; a <b; ++ a) tente {Ua [a] ()} catch (d) {c (d)} Ua = void 0})} finalmente {Ja ++}} função ma (a, b) {if (! A) retorna a; if (! A (a)) lança $ ("srcset", b, a.toString () ); para (var c = "", d = U (a), e = / (\ s + \ d + x \ s *, | \ s + \ d + w \ s *, | \ s +, |, \ s + ) /, e = / \ s / .test (d)? e: / (,) /, d = d.split (e), e = Math.floor (d.length /
2), f = 0; f <e; f ++) var g = 2 * f, c = c + u.getTrustedMediaUrl (U (d [g])), c = c + ("" + U (d [g + 1])); d = U (d [2 * f]). Split (/ \ s /); c + = u.getTrustedMediaUrl (U (d [0])); 2 === d.length && (c + = "" + U (d [1])); retornar c} função w (a, b) {if (b) {var c = Object.keys (b), d, e, f; d = 0; for ( e = c.length; d <e; d ++) f = c [d], este [f] = b [f]} mais isso. $ attr = {}; este. $$ elemento = a} função O (a , b, c) {Fa.innerHTML = "<span" + b + ">"; b = Fa.firstChild.attributes; var d = b [0]; b.removeNamedItem (d.name); d.value = c ; a.attributes.setNamedItem (d)} função sa (a, b) {try {a.addClass (b)} catch (c) {}}
função da (a, b, c, d, e) {uma instância de x || (a = x (a)); var f = Xa (a, b, a, c, d, e); da. $$ addScopeClass (a); var g = null; função de retorno (b, c, d) {if (! a) throw $ ("multilink"); gb (b, "scope"); e && e.needsNewScope && (b = b. $ parent. $ new ()); d = d || {}; var h = d.parentBoundTranscludeFn, k = d.transcludeControllers; d = d.futureParentElement; h && h. $$ boundTransclude && (h = h. $$ boundTransclude) ; g || (g = (d = d && d [0])? "objeto estrangeiro"! == ua (d) && la.call (d) .match (/ SVG /)? "svg": "html": "html "); d =" html "! == g? x (ja (g, x (" <div> </div> ") .append (a) .html ())): c? Wa.clone.call (uma):
a; if (k) para (var l in k) d.data ("$" + l + "Controller", k [l]. instância); da. $$ addScopeInfo (d, b); c && c (d, b ); f && f (b, d, d, h); c || (a = f = nulo); return d}} função Xa (a, b, c, d, e, f) {função g (a, c , d, e) {var f, k, l, m, p, I, t; se (n) for (t = Matriz (comprimento c), m = 0; m <comprimento h; m + = 3) f = h [m], t [f] = c [f]; caso contrário t = c; m = 0; para (p = h.length; m <p;) k = t [h [m ++]], c = h [m ++], f = h [m ++], c? (c.scope? (l = a. $ new (), da. $$ addScopeInfo (x (k), l)): l = a, I = c.transcludeOnThisElement? ka (a, c.transclude, e) :! c.templateOnThisElement && e? e:! e &&b? ka (a, b): null, c (f, l, k, d, I)): f &&f (a, k.childNodes,
vazio 0, e)} para (var h = [], k = H (a) || uma instância de x, l, m, p, I, n, t = 0; t <comprimento a; t ++) {l = new w; 11 === Ca && ib (a, t, k); m = sc (a [t], [], l, 0 === t? d: nulo 0, e); (f = m. comprimento? aa (m, a [t], l, b, c, nulo, [], [], f): nulo) && f.scope && da. $$ addScopeClass (elemento l. $$); l = f && f.terminal ||! (p = a [t] .childNodes) ||! p.length? null: Xa (p, f? (f.transcludeOnThisElement ||! f.templateOnThisElement) && f.transclude: b); if (f | | l) h.push (t, f, l), I =! 0, n = n || f; f = nulo} retorna I? g: nulo} função ib (a, b, c) {var d = a [b], e = d.parentNode, f; if (d.nodeType === Pa) para (;;) {f = e? d.nextSibling:
a [b + 1]; if (! f || f.nodeType! == Pa) break; d.nodeValue + = f.nodeValue; f.parentNode && f.parentNode.removeChild (f); c && f === a [b + 1] && a.splice (b + 1,1)}} função ka (a, b, c) {função d (e, f, g, h, k) {e || (e = a. $ New (! 1, k), e. $$ transcluído =! 0); return b (e, f, {parentBoundTranscludeFn: c, transcludeControllers: g, futureParentElement: h})} var e = d. $$ slots = T (), f; para (f em b. $$ slots) e [f] = b. $$ slots [f]? ka (a, b. $$ slots [f], c): null; return d} function sc ( a, b, d, e, f) {var g = d. $ attr, h; switch (a.nodeType) {caso 1: h = ua (a); X (b, wa (h), "E" , e, f); para (var l, m,
n, t, J, s = a.atributos, v = 0, G = s & s.length; v <G; v ++) {var P =! 1, N =! 1, r =! 1, y =! 1, u =! 1, M; l = s [v]; m = l.name; t = l.value; n = wa (m.toLowerCase ()); (J = n.match (Ra))? (r = "Atributo" === J [1], y = "Suporte" === J [1], u = "Ativado" === J [1], m = m. Substituir (pd, ""). toLowerCase (). substr (4 + J [1] .length) .replace (/_(.)/ g, function (a, b) {return b.toUpperCase ()})) :( M = n.match ( Sa)) && ca (M [1]) && (P = m, N = m.substr (0, m.length-5) + "final", m = m.substr (0, m.length-6)) ; if (y || u) d [n] = t, g [n] = l.name, y? Ea (a, b, n, m): b.push (qd (p, L, c, n , m,! 1)); else {n = wa (m.toLowerCase ()); g [n] = m; if (r ||! d.hasOwnProperty (n)) d [n] =
t, ld (a, n) && (d [n] =! 0); Ia (a, b, t, n, r); X (b, n, "A", e, f, P, N) }} "input" === h && "hidden" === a.getAttribute ("type") && a.setAttribute ("autocomplete", "off"); if (! Qa) break; g = a.className; D (g) && (g = g.animVal); if (A (g) && ""! == g) para (; a = k.exec (g);) n = wa (a [2]), X (b, n, "C", e, f) && (d [n] = U (a [3])), g = g.substr (a.index + a [0] .length); break; case Pa: na (b, a.nodeValue); break; case 8: if (! Oa) break; F (a, b, d, e, f)} b.sort (ia); return b} função F (a , b, c, d, e) {tente {var f = g.exec (a.nodeValue); se (f) {var h = wa (f [1]); X (b, h, "M", d, e) && (c [h] = U (f [2]))}} captura (k) {}}
função V (a, b, c) {var d = [], e = 0; if (b && a.hasAttribute && a.hasAttribute (b)) {do {if (! a) throw $ ("uterdir", b, c) ; 1 === a.nodeType && (a.hasAttribute (b) && e ++, a.hasAttribute (c) && e -); d.push (a); a = a.nextSibling} enquanto (0 <e)} else d .push (a); return x (d)} função Y (a, b, c) {função de retorno (d, e, f, g, h) {e = V (e [0], b, c); retornar a (d, e, f, g, h)}} função Z (a, b, c, d, e, f) {var g; retornar a? da (b, c, d, e, f): function () {g || (g = da (b, c, d, e, f), b = c = f = nulo); retorne g.apply (this, argumentos)}} function aa (a, b, d, e, f, g, h, k, l) {função m (a, b, c, d) {se (a) {c && (a =
Y (a, c, d)); a.require = u.require; a.directiveName = Q; if (s === u || u. $$ isolateScope) a = Aa (a, {isolateScope:! 0 }); h.push (a)} if (b) {c && (b = Y (b, c, d)); b.require = u.require; b.directiveName = Q; if (s === u $ isolateScope) b = Aa (b, {isolateScope:! 0}); k.push (b)}} função p (a, e, f, g, l) {função m (a, b , c, d) {var e; bb (a) || (d = c, c = b, b = a, a = nulo 0); N && (e = P); c || (c = N? Q .parent (): Q); if (d) {var f = l. $$ slots [d]; if (f) retornar f (a, b, e, c, R); if (z (f)) throw $ ("noslot", d, za (Q));} else return l (a, b, e, c, R)} var n, u, L, y, G, P, M, Q; b = == f? (g = d, Q = elemento d. $$) :( Q =
x (f), g = new w (Q, d)); G = e; s? y = e. $ new (! 0): t && (G = e. $ pai); l && (M = m, M . $$ boundTransclude = l, M.isSlotFilled = function (a) {return !! l. $$ slots [a]}); J && (P = ea (Q, g, M, J, y, e, s) ); s && (da. $$ addScopeInfo (Q, y,! 0,! (v && (v === s || v === s. $$ originalDirective)))), da. $$ addScopeClass (Q ,! 0), y. $$ isolateBindings = s. $$ isolateBindings, u = Da (e, g, y, y. $$ isolateBindings, s), u.removeWatches && y. $ On ("$ destroy", u.removeWatches) ); para (n em P) {u = J [n]; L = P [n]; var Cg = u. $$ bindings.bindToController; L.instance = L (); Q.data ("$" + u.name + "Controller", L. instância);
L.bindingInfo = Da (G, g, L.instance, Cg, u)} r (J, função (a, b) {var c = a.require; a.bindToController &&! H (c) && D (c) && S (P [b] .instância, W (b, c, Q, P))}); r (P, função (a) {var b = a.instância; se (B (b. $ OnChanges)) tentar { b. $ onChanges (a.bindingInfo.initialChanges)} catch (d) {c (d)} if (B (b. $ onInit)) tente {b. $ onInit ()} catch (e) {c (e) } B (b. $ DoCheck) && (G. $ watch (function () {b. $ DoCheck ()}), b. $ DoCheck ()); B (b. $ OnDestroy) && G. $ on ("$ destrua ", function () {b. $ onDestroy ()})}); n = 0; for (u = comprimento.n; u <n; n ++) L = h [n], Ba (L, L.isolateScope ? y: e, Q, g, L. requer && W (L.directiveName,
Você pode usar o seguinte método: ();) (); () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () l); para (n = k.length-1; 0 <= n; n -) L = k [n], Ba (L, L.isolateScope? y: e, Q, g, L. requere && W (L .directiveName, L.require, Q, P), M); r (P, função (a) {a = a.instância; B (a. $ postLink) && a. $ postLink ()})} l = l | | {}; para (var n = -Número.MAX_VALUE, t = l.newScopeDirective, J = l.controllerDirectives, s = l.newIsolateScopeDirective, v = l.templateDirective, L = l.nonTlbTranscludeDirective, G =! 1, P =! 1, N = l.hasElementTranscludeDirective, y = d. $$ elemento = x (b), u, Q,
M, R = e, q, ma =! 1, Ib =! 1, O, sa = 0, A = comprimento; sa <A; sa ++) {u = a [sa]; var E = u. $ $ start, ib = u. $$ end; E && (y = V (b, E, ib)); M = nulo 0; se (n> u.priority) quebrar; if (O = u.scope) u. templateUrl || (D (O)? (ba ("escopo novo / isolado", s || t, u, y), s = u): ba ("escopo novo / isolado", s, u, y)) , t = t || u; Q = u.name; if (! ma && (u.replace && (u.templateUrl || u.template) || u.template) || u.transclude &&! u. $$ tlb)) {for (O = sa + 1; ma = a [O ++];) if (ma.transclude &&! ma. $$ tlb || ma.replace && (ma.templateUrl || ma.template)) {Ib =! 0; break} ma =! 0}! U.templateUrl && u.controller && (J = J || T (), ba ("'" + Q + "' controller",
J [Q], u, y), J [Q] = u); if (O = u.classifica) if (G =! 0, u. $$ tlb || (ba ("transclusão", L, u , y), L = u), "elemento" === O) N =! 0, n = u.prioridade, M = y, y = d. $$ elemento = x (da. $$ createComment (Q, d [Q])), b = y [0], pa (f, Ha.call (M, 0), b), R = Z (Ib, M, e, n, g && g.name, {nonTlbTranscludeDirective: L }); else {var ka = T (); if (D (O)) {M = C.document.createDocumentFragment (); var Xa = T (), F = T (); r (O, função (a , b) {var c = "?" === a.charAt (0); a = c? a.substring (1): a; Xa [a] = b; ka [b] = nulo; F [b ] = c}); r (y.contents (), função (a) {var b = Xa [wa (ua (a))]; b? (F [b] =! 0, ka [b] = ka [b] || C.document.createDocumentFragment (),
ka [b] .appendChild (a)): M.appendChild (a)}); r (F, função (a, b) {if (! a) throw $ ("reqslot", b);}); para (var K em ka) ka [K] && (R = x (ka [K] .childNodes), ka [K] = Z (Ib, R, e)); M = x (M.childNodes)} else M = x (pc (b)). conteúdo (); y.vazia (); R = Z (Ib, M, e, vazio 0, vazio 0, {needsNewScope: u. $$ isolateScope || u. $$ newScope }); R. $$ slots = ka} if (u.template) if (P =! 0, ba ("modelo", v, u, y), v = u, O = B (u.template)? u.template (y, d): u.template, O = Na (O), u.replace) {g = u; M = mc.test (O)? rd (ja (u.templateNamespace, U (O)) )): []; b = M [0]; if (1! == M.length || 1! == b.nodeType) throw $ ("tplrt",
Q, ""); pa (f, y, b); A = {$ attr: {}}; O = sc (b, [], A); var Dg = a.splice (sa + 1, a. () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () } else y.html (O); if (u.templateUrl) P =! 0, ba ("modelo", v, u, y), v = u, u.replace && (g = u), p = ha ( a.splice (sa, a.length-sa), y, d, f, G&R, h, k, {controllerDirectives: J, newScopeDirective: t! == u &&, newIsolateScopeDirective: s, templateDirective: v, nonTlbTranscludeDirective: L} ), A = a.length; caso contrário, se (u.compile) tente {q = u.compile (y, d, R); var X = u. $$ originalDirective || u; B (q)? M (null , Va (X, q), E, ​​ib):
q && m (Va (X, q.pre), Va (X, q.post), E, ​​ib)} catch (ca) {c (ca, za (y))} u.terminal && (p.terminal =! 0 , n = Math.max (n, u.priority))} p.scope = t &&! 0 === t.scope; p.transcludeOnThisElement = G; p.templateOnThisElement = P; p.transclude = R; l.hasElementTranscludeDirective = N; retorna p} função W (a, b, c, d) {var e; se (A (b)) {var f = b.match (l); b = b.substring (f [0]). comprimento); var g = f [1] || f [3], f = "?" === f [2]; "^^" === g? c = c.parent (): e = ( e = d && d [b]) && e.instance; if (! e) {var h = "$" + b + "Controller"; e = "^^" === g && c [0] && 9 === c [0] .nodeType? null: g? c.inheritedData (h): c.data (h)} if (! e &&
! f) lança $ ("ctreq", b, a);} senão se (H (b)) para (e = [], g = 0, f = comprimento b; g <f; g ++) e [g ] = W (a, b [g], c, d); caso contrário, D (b) && (e = {}, r (b, função (b, f)) {e [f] = W (a, b, c, d)})); return e || null} função ea (a, b, c, d, e, f, g) {var h = T (), k; para (k em d) {var l = d [k], m = {$ scope: l === g || l. $$ isolateScope? e: f, $ elemento: a, $ attrs: b, $ transclude: c}, p = l.controller ; "@" === p && (p = b [l.name]); m = M (p, m,! 0, l.controllerAs); h [l.name] = m; a.data ("$ "+ l.name +" Controller ", m.instância)} retornar h} função fa (a, b, c) {for (var d = 0, e = comprimento.a; d <e; d ++) a [d] = ac (a [d], {$$ isolateScope: b,
$$ newScope: c})} função X (b, c, e, g, h, k, l) {if (c === h) retorna nulo; var m = nulo; if (f.hasOwnProperty (c) ) {h = a.get (c + "Diretiva"); for (var p = 0, n = h.length; p <n; p ++) if (c = h [p], (z (g) || g > c.priority) && - 1! == c.restrict.indexOf (e)) {k && (c = ac (c, {$$ início: k, $$ final: l})); if (! c. $$ bindings) {var I = m = c, t = c.name, u = {isolateScope: null, bindToController: null}; D (I.scope) && (! 0 === I.bindToController? (u. Você pode usar o seguinte método: <b> (</b>) </b>: <b> <b> </b> </b>: <b> <b> </b>: </b> = d (I.bindToController,
t,! 0)); if (u.bindToController &&! I.controller) lança $ ("noctrl", t); m = m. $$ ligações = u; D (m.isolateScope) && (c. $$ isolateBindings = m.isolateScope)} b.push (c); m = c}} retorna m} função ca (b) {if (f.hasOwnProperty (b)) for (var c = a.get (b + "Diretiva") , d = 0, e = c.length; d <e; d ++) if (b = c [d], b.multiElement) return! 0; return! 1} função ga (a, b) {var c = b . $ attr, d = a. $ attr; r (a, função (d, e) {"$"! == e.charAt (0) && (b [e] && b [e]! == d && (d = d.length? d + (("estilo" === e? ";": "") + b [e]): b [e]), a. $ set (e, d,! 0, c [ e]))}); r (b, função (b, e) {a.hasOwnProperty (e) ||
"$" === e.charAt (0) || (a [e] = b, "classe"! == e && "estilo"! == e && (d [e] = c [e]))}) } função ha (a, b, d, f, g, h, k, l) {var m = [], p, n, t = b [0], u = a.shift (), J = ac ( u, {templateUrl: null, transclude: null, substitua: null, $$ originalDirective: u}), s = B (u.templateUrl)? u.templateUrl (b, d): u.templateUrl, L = u.templateNamespace ; b.empty (); e (s) .then (function (c) {var e, I; c = Na (c); if (u.replace) {c = mc.test (c)? rd (ja (L, U (c))): []; e = c [0]; if (1! == c.length || 1! == e.nodeType) throw $ ("tplrt", u.name, s); c = {$ attr: {}}; pa (f, b, e); var v = sc (e, [], c); D (u.scope) && fa (v,! 0); a =
v.concat (a); ga (d, c)} else e = t, b.html (c); a.unshift (J); p = aa (a, e, d, g, b, u, h , k, l); r (f, função (a, c) {a === e && (f [c] = b [0])}); para (n = Xa (b [0] .childNodes, g ); m.length;) {c = m.shift (); I = m.shift (); var y = m.shift (), P = m.shift (), v = b [0]; if ( ! c. $$ destruído) {if (I! == t) {var G = I.className; l.hasElementTranscludeDirective && u.replace || (v = pc (e)); pa (y, x (I), v ); sa (x (v), G)} I = p.transcludeOnThisElement? ka (c, p.transclude, P): P; p (n, c, v, f, I)}} m = nulo}) .catch (function (a) {cc (a) && c (a)}); return function (a, b, c, d, e) {a = e; b. $$ destruído || (m? m.push (b,
c, d, a) :( p.transcludeOnThisElement && (a = ka (b, p.transclude, e)), p (n, b, c, d, a)))}} função ia (a, b) { var c = b.priority-a.priority; return 0! == c? c: a.name! == b.name?a.name<b.name?-1:1:a.index-b.index } função ba (a, b, c, d) {função e (a) {retornar a? "(módulo:" + a + ")": ""} se (b) jogar $ ("multidir", b.name , e (b. $$ moduleName), c.name, e (c. $$ moduleName), a, za (d));} function na (a, c) {var d = b (c,! 0) ; d && a.push ({priority: 0, compile: function (a) {a = a.parent (); var b = !! a.length; b && da. $$ addBindingClass (a); função de retorno (a, c) {var e = c.parent ();
b || da. $$ addBindingClass (e); da. $$ addBindingInfo (e, d.expressions); a. $ watch (d, função (a) {c [0] .nodeValue = a})}}} )} function ja (a, b) {a = K (a || "html"); switch (a) {case "svg": case "math": var c = C.document.createElement ("div") ; c.innerHTML = "<" + a + ">" + b + "</" + a + ">"; retornar c.childNodes [0] .childNodes; padrão: retornar b}} função oa (a, b) {if ("srcdoc" === b) retorna u.HTML; if ("src" === b || "ngSrc" === b) return-1 === ["img", "video", "audio "," origem "," faixa "]. indexOf (a)? u.RESOURCE_URL: u.MEDIA_URL; if (" xlinkHref "=== b) retorne" image "=== a? u.MEDIA_URL:
"a" === a? u.URL: u.RESOURCE_URL; if ("forma" === a && "ação" === b || "base" === a && "href" === b || "link" === a && "href" === b) retorna u.RESOURCE_URL; if ("a" === a && ("href" === b || "ngHref" === b)) retorna u .URL} função xa (a, b) {var c = b.toLowerCase (); return v [a + "|" + c] || v ["* |" + c]} função ya (a) {return ma (u.valueOf (a), "ng-prop-srcset")} função Ea (a, b, c, d) {if (m.test (d)) lança $ ("nodomevents"); a = ua ( a); var e = xa (a, d), f = Ta; "srcset"! == d || "img"! == a && "fonte"! == a? e && (f = u.getTrusted.bind (u, e)): f = ya; b.push ({prioridade: 100, compilação: função (a, b) {var e =
p (b [c]), g = p (b [c], função (a) {return u.valueOf (a)}); return {pre: function (a, b) {function c () {var g = e (a); b [0] [d] = f (g)} c (); a. $ watch (g, c)}}}})} função função Ia (a, c, d, e, f ) {var g = ua (a), k = oa (g, e), l = h [e] || f, p = b (d,! f, k, l); if (p) {if ( "multiple" === e && "select" === g) throw $ ("selmulti", za (a)); if (m.test (e)) throw $ ("nodomevents"); c.push ({ prioridade: 100, compile: function () {return {pre: function (a, c, f) {c = f. $$ observadores || (f. $$ observadores = T ()); var g = f [e ]; g! == d && (p = g &&b (g,! 0, k, l), d = g); p && (f [e] = p (a), (c [e] || (c [e ] = [])). $$ inter =! 0, (f. $$ observadores &&
f. $$ observadores [e]. $$ escopo || a). $ watch (p, função (a, b) {"class" === e && a! == b? f. $ updateClass (a, b) : f. $ set (e, a)}))}}})}}} função pa (a, b, c) {var d = b [0], e = comprimento b, f = d.parentNode, g, h; se (a) para (g = 0, h = a.length; g <h; g ++) if (a [g] === d) {a [g ++] = c; h = g + e -1; para (var k = a.length; g <k; g ++, h ++) h <k? A [g] = a [h]: exclui a [g]; a.length- = e-1; a .context === d && (a.context = c); break} f &&f.replaceChild (c, d); a = C.document.createDocumentFragment (); para (g = 0; g <e; g ++) a.appendChild (b [g]); x.hasData (d) && (x.data (c, x.data (d)), x (d) .off ("$ destroy")); x.cleanData (a.querySelectorAll ("*"));
para (g = 1; g <e; g ++) excluir b [g]; b [0] = c; b.length = 1} função Aa (a, b) {retornar S (função () {retornar a.apply (null, argumentos)}, a, b)} função Ba (a, b, d, e, f, g) {tente {a (b, d, e, f, g)} catch (h) {c ( h, za (d))}} função ra (a, b) {if (s) throw $ ("missingattr", a, b);} função Da (a, c, d, e, f) {função g (b, c, e) {B (d. $ onChanges) &&! dc (c, e) && (Ua || (a. $$ postDigest (q), Ua = []), m || (m = {}, Ua.push (h)), m [b] && (e = m [b] .Valor anterior), m [b] = nova Jb (e, c))} função h () {d. $ OnChanges (m); m = nulo 0} var k = [], l = {}, m; r (e, função (e, h) {var m = e.attrName, n = e.opcional,
I, t, u, s; switch (e.mode) {case "@": n || ta.call (c, m) || (ra (m, nome f)), d [h] = c [ m] = vazio 0); n = c. $ observe (m, função (a) {se (A (a) || Ga (a)) g (h, a, d [h]), d [h] = a}); c. $$ observadores [m]. $$ escopo = a; I = c [m]; A (I)? d [h] = b (I) (a): Ga (I) && (d [h] = I); l [h] = new Jb (tc, d [h]); k.push (n); break; case "=": if (! ta.call (c, m) ) {if (n) break; ra (m, f.name); c [m] = void 0} if (n &&! c [m]) break; t = p (c [m]); s = t. literal? va: dc; u = t.assign || function () {I = d [h] = t (a); lança $ ("nonassign", c [m], m, f.name);}; I = d [h] = t (a); n = função (b) {s (b, d [h]) || (s (b, I)? U (a, b = d [h]): d [h] = b); retorno I =
b}; n. $ stateful =! 0; n = e.collection? a. $ watchCollection (c [m], n): a. $ watch (p (c [m], n), nulo, t.literal ); k.push (n); break; case "<": if (! ta.call (c, m)) {if (n) break; ra (m, nome de f.); c [m] = vazio 0} se (n &&! C [m]) quebra; t = p (c [m]); var v = t.literal, L = d [h] = t (a); l [h] = new Jb ( tc, d [h]); n = a [e.collection? "$ watchCollection": "$ watch"] (t, função (a, b) {if (b === a) {if (b == = L || v && va (b, L)) return; b = L} g (h, a, b); d [h] = a}); k.push (n); break; case "&": n || ta.call (c, m) || ra (m, f.name); t = c.hasOwnProperty (m)? p (c [m]): E; se (t === E & n) quebra; d [h] = função (b) {retorna t (a,
b)}}}); return {initialChanges: l, removeWatches: k.length && function () {for (var a = 0, b = k.length; a <b; ++ a) k [a] ()}} } var Ma = / ^ \ w /, Fa = C.document.createElement ("div"), Oa = t, Qa = N, Ja = G, Ua; w.prototype = {$ normalize: wa, $ addClass: function (a) {a && 0 <a.length && R.addClass (this. $$ elemento, a)}, $ removeClass: function (a) {a && 0 <a.length && R.removeClass (this. $$ elemento, a)}, $ updateClass: function (a, b) {var c = sd (a, b); c && c.length && R.addClass (este elemento. $$, c); (c = sd (b, a)) && c.length && R.removeClass ( este. $$ elemento, c)}, $ set: function (a, b, d, e) {var f =
ld (este. $$ elemento [0], a), g = td [a], h = a; f? (este. $$ elemento.prop (a, b), e = f): g && (este [ g] = b, h = g); isto [a] = b; e? isto. $ attr [a] = e: (e = isto. $ attr [a]) || (isto. $ attr [a] = e = Vc (a, "-")); "img" === ua (este elemento. $$) && "srcset" === a && (este [a] = b = ma (b, "$ set ('srcset', valor) ")) ;! 1! == d && (null === b || z (b)? isto. $$ element.removeAttr (e): Teste.teste (e)? f &&! 1 === b? This. $$ element.removeAttr (e): this. $$ element.attr (e, b): O (this. $$ elemento [0], e, b)); (a = this. $$ observers) && r (a [h], function (a) {try {a (b)} catch (d) {c (d)}})}, $ observe: function (a, b) {var c = isso,
d = c. $$ observadores || (c. $$ observadores = T ()), e = d [a] || (d [a] = []); e.push (b); L. $ evalAsync (função () {e. $$ inter ||! c.hasOwnProperty (a) || z (c [a]) || b (c [a])}); função de retorno () {cb (e, b var Ka = b.startSymbol (), La = b.endSymbol (), Na = "{{" "Ka &&"}} "=== La? Ta: function (a) {return a .replace (/ \ {\ {/ g, Ka) .replace (/}} / g, La)}, Ra = / ^ ng (Attr | Prop | On) ([AZ]. *) $ /, Sa = /^(.+)Start$/;da.$$addBindingInfo=n?function(a,b){var c = a.data ("$ binding") || []; H (b)? C = c .concat (b): c.push (b); a.data ("$ binding", c)}: E; da. $$ addBindingClass = n? function (a) {sa (a,
"ng-binding")}: E; da. $$ addScopeInfo = n? function (a, b, c, d) {a.data (c? d? "$ isolateScopeNoTemplate": "$ isolateScope": "$ scope ", b)}: E; da. $$ addScopeClass = n? função (a, b) {sa (a, b?" ng-isolate-scope ":" ng-scope ")}: E; da. $ $ createComment = função (a, b) {var c = ""; n && (c = "" + (a || "") + ":", b && (c + = b + "")); retorne C.document. createComment (c)}; return da}]} função Jb (a, b) {this.previousValue = a; this.currentValue = b} função wa (a) {return a.replace (pd, ""). replace ( Por exemplo, function (a, d, c) {return c? D.toUpperCase (): d})} function sd (a, b) {var d =
"", c = fenda (/ \ s + /), e = fenda (/ \ s + /), f = 0; a: for (; f <comprimento.c; f ++) {for (var g = c [f], k = 0; k <e.length; k ++) se (g === e [k]) continuar a; d + = (0 <d.length? "": "") + g} return d} função rd (a) {a = x (a); var b = a.length; if (1> = b) retorna a; for (; b -;) {var d = a [b]; ( 8 === d.nodeType || d.nodeType === Pa && "" === d.nodeValue.trim ()) && Fg.call (a, b, 1)} retorna uma} função Bg (a, b) {if (b && A (b)) retorna b; if (A (a)) {var d = ud.exec (a); if (d) retorna d [3]}} função Ff () {var a = {} ; this.has = function (b) {return a.hasOwnProperty (b)}; this.register = function (b, d) {Ja (b,
"controlador"); D (b)? S (a, b): a [b] = d}; isto. $ get = ["$ injector", função (b) {função d (a, b, d, g) {if (! a ||! D (a. $ scope)) lança F ("$ controller") ("noscp", g, b); a. $ scope [b] = d} função de retorno (c , e, f, g) {var k, h, l; f =! 0 === f; g && A (g) && (l = g); se (A (c)) {g = c.match (ud ); se (! g) joga vd ("ctrlfmt", c); h = g [1]; l = l || g [3]; c = a.hasOwnProperty (h)? a [h]: Ge ( e. $ scope, h,! 0); if (! c) lança vd ("ctrlreg", h); sb (c, h,! 0)} if (f) retorna f = (H (c)? c [c.length-1]: c) .prototype, k = Object.create (f || nulo), l & d (e, l, k, h || nome c), S (função () {var a = invoque (c, k, e, h);
a! == k && (D (a) || B (a)) && (k = a, l &&d (e, l, k, h || nome do c)); return k}, {instance: k, identifier : l}); k = b.instantiate (c, e, h); l && d (e, l, k, h || nome do c); return k}}]} função Gf () {this. $ get = ["$ window", function (a) {return x (a.document)}]} function Hf () {this. $ get = ["$ document", "$ rootScope", function (a, b) {function d () {e = c.hidden} var c = a [0], e = c && c.hidden; a.on ("troca de visibilidade", d); b. $ on ("$ destroy", function () {a .off ("visiblechange", d)}); return function () {return e}}]} function If () {this. $ get = ["$ log", function (a) {return function (b,
d) {a.error.apply (a, argumentos)}}]} função uc (a) {retornar D (a)? ha (a)? a.toISOString (): eb (a): a} função Of ( ) {this. $ get = function () {return function (a) {if (! a) return ""; var b = []; Oc (a, função (a, c) {null === a || z (a) || B (a) || (H (a)? r (a, função (a) {b.push (ba (c) + "=" + ba (uc (a)))}) : b.push (ba (c) + "=" + ba (uc (a))))}); retorne b.join ("&")}}} função Pf () {this. $ get = function ( ) {função de retorno (a) {função b (a, e, f) {H (a)? r (a, função (a, c) {b (a, e + "[" + (D (a)? c : "") + "]")}): D (a) &&! Ha (a)? Oc (a, função (a, c) {b (a, e + (f? "": "[") + c + (f? "": "]"))}):
(B (a) && (a = a ()), d.push (ba (e) + "=" + (null == a? "": Ba (uc (a)))))} if (! a) return ""; var d = []; b (a, "" ,! 0); return d.join ("&")}}} função vc (a, b) {if (A (a)) {var d = a.replace (Gg, ""). trim (); if (d) {var c = b ("Content-Type"), c = c && 0 === c.indexOf (wd), e; (e = c) || ​​(e = (e = d.match (Hg)) && Ig [e [0]]. teste (d)); se (e) tentar {a = Rc (d)} captura (f) ) {if (! c) retorna a; lança Kb ("dados inválidos", a, f);}}} retorna a} função xd (a) {var b = T (), d; A (a)? r ( a.split ("\ n"), função (a) {d = a.indexOf (":"); var e = K (U (a.substr (0, d))); a = U (a. substr (d + 1)); e && (b [e] = b [e]? b [e] + "," + a: a)}): D (a) &&
r (a, função (a, d) {var f = K (d), g = U (a); f && (b [f] = b [f]? b [f] + "," + g: g )}); return b} função yd (a) {var b; função de retorno (d) {b || (b = xd (a)); return d? (d = b [K (d)], void 0 === d && (d = nulo), d): b}} função zd (a, b, d, c) {if (B (c)) retorna c (a, b, d); r (c, função (c) {a = c (a, b, d)}); retorna uma} função Nf () {var a = this.defaults = {transformResponse: [vc], transformRequest: [function (a) {return D ( a) && "[arquivo do objeto]"! == la.call (a) && "[objeto Blob]"! == la.call (a) && "[objeto FormData]"! == la.call (a) ? eb (a): a}], cabeçalhos: {comuns: {Accept: "application / json, text / plain, * / *"},
post: ja (wc), colocar: ja (wc), patch: ja (wc)}, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", paramSerializer: "$ httpParamSerializer", jsonpCallbackParam: " retorno de chamada "}, b =! 1; this.useApplyAsync = function (a) {return w (a)? (b = !! a, this): b}; var d = this.interceptors = [], c = this .xsrfWhitelistedOrigins = []; this. $ get = ["$ browser", "$ httpBackend", "$$ cookieReader", "$ cacheFactory", "$ rootScope", "$ q", "$ injector", "$ sce ", função (e, f, g, k, h, l, m, p) {função n (b) {função c (a, b) {para (var d = 0, e = b.length; d <e;) {var f = b [d ++], g = b [d ++];
a = a.then (f, g)} b.length = 0; retorna a} função d (a, b) {var c, e = {}; r (a, função (a, d) {B (a )? (c = a (b), nulo! = c && (e [d] = c)): e [d] = a}); retorna e} função f (a) {var b = S ({}, a); b.data = zd (a.data, a.headers, a.status, g.transformResponse); a = a.status; return 200 <= a && 300> a? b: l.reject (b)} se (! D (b)) jogue F ("$ http") ("badreq", b); if (! A (p.valueOf (b.url))) jogue F ("$ http") ("badreq" , b.url); var g = S ({método: "get", transformRequest: a.transformRequest, transformResponse: a.transformResponse, paramSerializer: a.paramSerializer, jsonpCallbackParam: a.jsonpCallbackParam},
b); g.headers = função (b) {var c = a.headers, e = S ({}, b.headers), f, g, h, c = S ({}, c.common, c [ K (b.method)]); a: for (f em c) {g = K (f); for (h em e) se (K (h) === g) continuar a; e [f] = c [f]} return d (e, ja (b))} (b); g.method = ub (g.method); g.paramSerializer = A (g.paramSerializer)? m.get (g.paramSerializer) : g.paramSerializer; e. $$ incOutstandingRequestCount ("$ http"); var h = [], k = []; b = l.resolve (g); r (v, function (a) {(a.request || a.requestError) && h.unshift (a.request, a.requestError); (a.response || a.responseError) && k.push (a.response, a.responseError)});
b = c (b, h); b = b.then (function (b) {var c = b.headers, d = zd (b.dados, yd (c), void 0, b.transformRequest); z ( d) && r (c, função (a, b) {"tipo de conteúdo" === K (b) && delete c [b]}); z (b.Com credenciais) &&! z (a. com credenciais) && (b .withCredentials = a.withCredentials); return s (b, d) .then (f, f)}); b = c (b, k); return b = b.finally (function () {e. $$ completeOutstandingRequest (E, "$ http")})} função s (c, d) {função e (a) {if (a) {var c = {}; r (a, função (a, d) {c [d ] = função (c) {função d () {a (c)} b? h. $ applyAsync (d): h. $$ phase? d (): h. $ apply (d)}}); return c }} função k (a,
c, d, e, f) {função g () {m (c, a, d, e, f)} R && (200 <= a && 300> a? R.put (O, [a, c, xd (d ), e, f]): R.remove (O)); b? h. $ applyAsync (g) :( g (), h. $$ phase || h. $ phase || h. $ apply ())} função m (a , b, d, e, f) {b = -1 <= b? b: 0; (200 <= b && 300> b? L.resolve: L.reject) ({data: a, status: b, headers: yd (d), config: c, statusText: e, xhrStatus: f})} função s (a) {m (a.data, a.status, ja (a.headers ()), a.statusText, a. xhrStatus)} função v () {var a = n.pendingRequests.indexOf (c); - 1! == a && n.pendingRequests.splice (a, 1)} var L = l.defer (), u = L.promise , R, q, ma = c.headers, x = "jsonp" === K (c.method),
O = c.url; x? O = p.getTrustedResourceUrl (O): A (O) || (O = p.valorOf (O)); O = G (O, c.paramSerializer (c.params)); x && (O = t (O, c.jsonpCallbackParam)); n.pendingRequests.push (c); u.then (v, v) ;! c.cache &&! a.cache ||! 1 === c.cache || "GET"! == c.method && "JSONP"! == c.method || (R = D (c.cache)? C.cache: D (a.cache)? A.cache: N); R && (q = R.get (O), w (q)? Q && B (q.then)? Q.then (s, s): H (q)? M (q [1], q [0], ja (q [2]), q [3], q [4]): m (q, 200, {}, "OK", "completo"): R.put (O, u)); z (q) && ((q = jc (c.url)? g () [c.xsrfCookieName || a.xsrfCookieName]: void 0) && (ma [c.xsrfHeaderName || a.xsrfHeaderName] =
q), f (c.method, O, d, k, ma, c.timeout, c.withCredentials, c.responseType, e (c.eventHandlers), e (c.uploadEventHandlers))); return u} função G (a, b) {0 <comprimento b && (a + = (- 1 === a.indexOf ("?")? "?": "&") + b); retorna a} função t (a, b ) {var c = a.split ("?"); if (2 <c.length) lança Kb ("badjsonp", a); c = gc (c [1]); r (c, function (c, d) {if ("JSON_CALLBACK" === c) lance Kb ("badjsonp", a); if (d === b) lance Kb ("badjsonp", b, a);}); retorne a + = ( -1 === a.indexOf ("?")? "?": "&") + B + "= JSON_CALLBACK"} var N = k ("$ http"); a.paramSerializer = A (a.paramSerializer) ? m.get (a.paramSerializer):
a.paramSerializer; var v = []; r (d, function (a) {v.unshift (A (a)? m.get (a): m.invoke (a))}); var jc = Jg ( c); n.pendingRequests = []; (função (a) {r (argumentos, função (a) {n [a] = função (b, c) {return n (S ({}, c || {} , {método: a, url: b}))}})}) ("get", "delete", "head", "jsonp"); (function (a) {r (argumentos, function (a) { n [a] = função (b, c, d) {retorna n (S ({}, d || {}, {método: a, url: b, dados: c}))}})}) (" post "," put "," patch "); n.defaults = a; return n}]} function Rf () {this. $ get = function () {return function () {retorna novo C.XMLHttpRequest}}} função Qf () {this. $ get =
["$ browser", "$ jsonpCallbacks", "$ document", "$ xhrFactory", função (a, b, d, c) {retorna Kg (a, c, a.defer, b, d [0]) }]} função Kg (a, b, d, c, e) {função f (a, b, d) {a = a.replace ("JSON_CALLBACK", b); var f = e.createElement ("script" ), m = null; f.type = "text / javascript"; f.src = a; f.async =! 0; m = function (a) {f.removeEventListener ("carga", m); f.removeEventListener ("erro", m); e.body.removeChild (f); f = nulo; var g = -1, s = "desconhecido"; a && ("carga"! == a.type || c.wasCalled ( b) || (a = {type: "error"}), s = a.type, g = "error" === a.type? 404: 200); d && d (g, s)}; f.addEventListener ("carga",
m); f.addEventListener ("erro", m); e.body.appendChild (f); return m} função de retorno (e, k, h, l, m, p, n, s, G, t) { função N (a) {J = "timeout" === a; qa && qa (); y && y.abort ()} função v (a, b, c, e, f, g) {w (P) && d.cancel ( P); qa = y = nulo; a (b, c, e, f, g)} k = k || a.url (); if ("jsonp" === K (e)) var q = c .createCallback (k), qa = f (k, q, função (a, b) {var d = 200 === a && c.getResponse (q); v (l, a, d, "", b, "complete "); c.removeCallback (q)}); else {var y = b (e, k), J =! 1; y.open (e, k,! 0); r (m, função (a, b ) {w (a) && y.setRequestHeader (b, a)}); y.onload = function () {var a = y.statusText ||
"", b = "resposta" na resposta y? y.response: y.responseText, c = 1223 === status y? 204: status y; 0 === c && (c = b? 200: "arquivo" === ga (k) .protocol? 404: 0); v (l, c, b, y.getAllResponseHeaders (), a, "complete")}; y.onerror = function () {v (l, - 1, nulo, nulo, "", "erro")}; y.ontimeout = function () {v (l, -1, nulo, nulo, "", "timeout")}; y.onabort = function () {v (l, -1, null, null, "", J? "timeout": "abort")}; r (G, função (a, b) {y.addEventListener (b, a)}); r (t, function (a, b) {y.upload.addEventListener (b, a)}); n && (y.withCredentials =! 0); se (s) tente {y.responseType = s} catch (I) { if ("json"! ==
s) jogue I;} y.envie (z (h)? null: h)} se (0 <p) var P = d (função () {N ("tempo limite")}, p); caso contrário, p &&B (p .then) && p.then (function () {N (w (p. $$ timeoutId)? "timeout": "abort")})}} function Kf () {var a = "{{", b = " }} "; this.startSymbol = function (b) {return b? (a = b, this): a}; this.endSymbol = function (a) {return a? (b = a, this): b}; $ get = ["$ parse", "$ exceptionHandler", "$ sce", função (d, c, e) {função f (a) {retorno "\\\\\\" + a} função g (c) {return c.replace (p, a) .replace (n, b)} função k (a, b, c, d) {var e = a. $ watch (função (a) {e (); return d (a)}, b, c); return e}
função h (f, h, n, p) {função v (a) {tente {retornar a = n &&! r? e.getTrusted (n, a): e.valueOf (a), p &&! w (a)? a: ic (a)} catch (b) {c (Ma.interr (f, b))}} var r = n === e.URL || n === e.MEDIA_URL; if (! f. comprimento || -1 === f.indexOf (a)) {if (h) return; h = g (f); r && (h = e.getTrusted (n, h)); h = ia (h); h.exp = f; h.expressions = []; h. $$ watchDelegate = k; return h} p = !! p; para (var q, y, J = 0, I = [], P, Q = f.length, M = [], L = [], u; J <Q;) if (-1! == (q = f.índice de (a, J)) && - 1! == (y = f .indexOf (b, q + l))) J! == q && M.push (g (f.substring (J, q))), J = f.substring (q + l, y), I.push (J ), J = y + m, L.push (comprimento M.),
M.push (""); else {J! == Q && M.push (g (f.substring (J))); break} u = 1 === comprimento M. && 1 === comprimento L.; var R = r && u? void 0: v; P = I.map (função (a) {return d (a, R)}); if (! h || I.length) {var x = function (a) {for (var b = 0, c = comprimento.I; b <c; b ++) {if (p && z (a [b])) return; M [L [b]] = a [b]} if (r) return e.getTrusted (n, u? M [0]: M.join ("")); n && 1 <M.length && Ma.throwNoconcat (f); return M.join ("")}; return S (function (a) {var b = 0, d = comprimento I., e = Matriz (d); tente {para (; b <d; b ++) e [b] = P [b] (a); retorne x (e)} captura (g) {c (Ma.interr (f, g))}}, {exp: f, expressões: I, $$ watchDelegate: function (a,
b) {var c; retorna a. $ watchGroup (P, função (d, e) {var f = x (d); b.call (this, f, d! == e? c: f, a); c = f})}})}} var l = a.length, m = b.length, p = new RegExp (a.replace (/./g, f), "g"), n = new RegExp ( b.replace (/./g, f), "g"); h.startSymbol = function () {retornar a}; h.endSymbol = function () {return b}; return h}]} function Lf () {this. $ get = ["$$ intervalFactory", "$ window", função (a, b) {var d = {}, c = função (a) {b.clearInterval (a); delete d [a] }, e = a (função (a, c, e) {a = b.setInterval (a, c); d [a] = e; retorna a}, c); e.cancel = function (a) {if (! a) return! 1; if (! a.hasOwnProperty ("$$ intervalId")) lança Lg ("badprom");
if (! d.hasOwnProperty (a. $$ intervalId)) return! 1; a = a. $$ intervalId; var b = d [a], e = b.promise; e. $$ state && (e. $$ state.pur =! 0); b.reject ("cancelado"); c (a); return! 0}; return e}]} função Mf () {this. $ get = ["$ browser", "$ q "," $$ q "," $ rootScope ", função (a, b, d, c) {função de retorno (e, f) {função de retorno (g, k, h, l) {função m () { p? g.apply (null, n): g (s)} var p = 4 <argumentos.length, n = p? Ha.call (argumentos, 4): [], s = 0, G = w (l ) &&! l, t = (G? d: b) .defer (), r = t.promise; h = w (h)? h: 0; r. $$ intervalId = e (function () {G? a.defer (m): c. $ evalAsync (m); t.notify (s ++);
0 <h && s> = h && (t.resolve (s), f (r. $$ intervalId)); G || c. $ Apply ()}, k, t, G); return r}}}]} função Anúncio (a, b) {var d = ga (a); b. $$ protocol = d.protocol; b. $$ host = d.hostname; b. $$ port = fa (d.port) || Mg [d.protocol] || null} função Bd (a, b, d) {if (Ng.test (a)) lança jb ("caminho incorreto", a); var c = "/"! == a.charAt (0); c && (a = "/" + a); a = ga (a); for (var c = (c && "/" === a.pathname.charAt (0)? A.pathname.substring ( 1): a.pathname) .split ("/"), e = c.length; e -;) c [e] = decodeURIComponent (c [e]), d && (c [e] = c [e] .replace (/ \ // g, "% 2F")); d = c.join ("/"); b. $$ caminho = d; b. $$ pesquisa = gc (a.search);
b. $$ hash = decodeURIComponent (a.hash); b. $$ caminho && "/"! == b. $$ caminho.charAt (0) && (b. $$ caminho = "/" + b. $$ caminho)} função xc (a, b) {retornar a.slice (0, b.length) === b} função xa (a, b) {if (xc (b, a)) retornar b.substr (a .length)} função Da (a) {var b = a.indexOf ("#"); return-1 === b? a: a.substr (0, b)} função yc (a, b, d) {this. $$ html5 =! 0; d = d || ""; Anúncio (a, isso); isso. $$ parse = função (a) {var d = xa (b, a); if (! A (d)) lança jb ("ipthprfx", a, b); Bd (d, este,! 0); este. $$ caminho || (este. $$ caminho = "/"); este. $$ compõe ()}; this. $$ normalizeUrl = function (a) {return b + a.substr (1)};
this. $$ parseLinkUrl = function (c, e) {if (e && "#" === e [0]) retorna this.hash (e.slice (1)) ,! 0; var f, g; w ( f = xa (a, c))? (g = f, g = d && w (f = xa (d, f))? b + (xa ("/", f) || f): a + g): w (f = xa (b, c))? g = b + f: b === c + "/" && (g = b); g&& this. $$ parse (g); return !! g}} função zc ( a, b, d) {Ad (a, this); this. $$ parse = function (c) {var e = xa (a, c) || ​​xa (b, c), f; z (e) | | "#"! == e.charAt (0)? this. $$ html5? f = e: (f = "", z (e) && (a = c, substitua ())) :( f = xa (d, e), z (f) && (f = e)); Bd (f, isto,! 1); c = isso. $$ caminho; var e = a, g = / ^ \ / [ AZ]: (\ /.*) /; xc (f, e) && (f = f. substituir (e, "")); g.exec (f) || (c = (f = g.exec ( c))?
f [1]: c); este. $$ caminho = c; este. $$ compor ()}; este. $$ normalizeUrl = função (b) {retornar a + (b? d + b: "")}; this. $$ parseLinkUrl = function (b, d) {return Da (a) === Da (b)? (this. $$ parse (b) ,! 0) :! 1}} function Cd (a, b , d) {this. $$ html5 =! 0; zc.apply (this, argumentos); this. $$ parseLinkUrl = function (c, e) {if (e && "#" === e [0]) return Se a resposta ajudou de alguma forma, por favor, marque como resposta, caso a sua dúvida não tenha sido solucionada, por favor, poste novamente. g: b === c + "/" && (f = b); f&& this. $$ parse (f); return !! f}; this. $$ normalizeUrl = function (b) {return a + d + b} } função Lb (a) {retornar função () {retornar esta [a]}} função Dd (a,
b) {função de retorno (d) {if (z (d)) retorna este [a]; isso [a] = b (d); isto. $$ compose (); retorna isso}} função Tf () {var a = "!", b = {ativado:! 1, requireBase:! 0, rewriteLinks:! 0}; this.hashPrefix = function (b) {return w (b)? (a = b, this): a} ; this.html5Mode = function (a) {if (Ga (a)) return b.enabled = a, this; if (D (a)) {Ga (a.enabled) && (b.enabled = a.enabled) ; Ga (a.requireBase) && (b.requireBase = a.requireBase); if (Ga (a.rewriteLinks) || A (a.rewriteLinks)) b.rewriteLinks = a.rewriteLinks; retornar isso} retornar b}; $ get = ["$ rootScope", "$ browser", "$ sniffer",
"$ rootElement", "$ window", função (d, c, e, f, g) {função k (a, b) {retorna a === b || ga (a) .href === ga ( b) .href} função h (a, b, d) {var e = m.url (), f = m. estado $$; tente {c.url (a, b, d), estado m. $$ = c.state ()} catch (g) {throw m.url (e), m. $$ state = f, g;}} função l (a, b) {d. $ broadcast ("$ locationChangeSuccess", m.absUrl (), a, m. $$ state, b)} var m, p; p = c.baseHref (); var n = c.url (), s; if (b.enabled) {if ( ! p && b.requireBase) throw jb ("nobase"); s = n.substring (0, n.indexOf ("/", n.indexOf ("//") + 2)) + (p || "/" ); p = e.history? yc: Cd} else s = Da (n), p = zc; var r = s.substr (0,
Da (s) .lastIndexOf ("/") + 1); m = novo p (s, r, "#" + a); m. $$ parseLinkUrl (n, n); m. $$ state = c. state (); var t = / ^ \ s * (javascript | mailto): / i; f.on ("clique", função (a) {var e = b.rewriteLinks; if (e &&! a.ctrlKey &&! a .metaKey &&! a.shiftKey && 2! == a.which && 2! == a.button) {for (var g = x (a.target); "a"! == ua (g [0]);) if (g [0] === f [0] ||! (G = g.parent ()) [0]) return; if (! A (e) ||! Z (g.attr (e))) {var e = g.prop ("href"), h = g.attr ("href") || g.attr ("xlink: href"); D (e) && "[objeto SVGAnimatedString]" === e. toString () && (e = ga (e.animVal) .href); t.test (e) ||! e || g.attr ("target") ||
a.isDefaultPrevented () ||! m. $$ parseLinkUrl (e, h) || (a.preventDefault (), m.absUrl ()! == c.url () && d. $ apply ())}}}} (); m.absUrl ()! == n && c.url (m.absUrl () ,! 0); var N =! 0; c.onUrlChange (função (a, b) {xc (a, r)? (d $ evalAsync (function () {var c = m.absUrl (), e = m. $$ state, f; m. $$ parse (a); m. $$ state = b; f = d. $ broadcast ("$ locationChangeStart", a, c, b, e) .defaultPrevented; m.absUrl () === a && (f? (m. $$ parse (c), m. $$ state = e, h (c ,! 1, e)) :( N =! 1, l (c, e)))}), fase d. $$ || d. $ Digest ()): g.location.href = a}); d. $ watch (function () {if (N || m. $$ urlUpdatedByLocation) {m. $$ urlUpdatedByLocation =
! 1; var a = c.url (), b = m.absUrl (), f = c.state (), g = m. $$ substituir, n =! K (a, b) || m. $ $ html5 && e.history && f! == m. $$ state; if (N || n) N =! 1, d. $ evalAsync (function () {var b = m.absUrl (), c = d. $ broadcast ( "$ locationChangeStart", b, a, m. $$ state, f) .defaultPrevented; m.absUrl () === b && (c? (m. $$ parse (a), m. $$ state = f) : (n && h (b, g, f === m. $$ state? null: m. $$ state), l (a, f)))})} m. $$ replace =! 1}); return m}]} função Uf () {var a =! 0, b = isto; this.debugEnabled = função (b) {retorno w (b)? (a = b, isto): a}; isso. $ get = ["$ window", função (d) {função c (a) {cc (a) && (a.stack &&
f? a = a.message && - 1 === a.stack.indexOf (a.message)? "Erro:" + a.message + "\ n" + a.stack: a.stack: a.sourceURL && (a = a.message + "\ n" + a.sourceURL + ":" + a.line)); retorna a} função e (a) {var b = d.console || {}, e = b [a] || b .log || E; função de retorno () {var a = []; r (argumentos, função (b) {a.push (c (b))}); return Function.prototype.apply.call (e, b , a)}} var f = Ca || / \ bEdge \ //. test (d.navigator && d.navigator.userAgent); retornar {log: e ("log"), informações: e ("info"), avisar : e ("aviso"), erro: e ("erro"), depuração: função () {var c = e ("depuração"); função de retorno () {a && c.apply (b,
argumentos)}} ()}}]} função Og (a) {retornar a + ""} função Pg (a, b) {retornar "indefinido"! == tipo de a? a: b} função Ed (a, b) {return "undefined" === tipo de a? b: "undefined" === tipo de b? a: a + b} função Qg (a, b) {switch (a.type) {case q.MemberExpression: if ( a.computed) return! 1; break; case q.UnaryExpression: return 1; case q.BinaryExpression: return "+"! == a.operator? 1:! 1; case q.CallExpression: return! 1} return void 0 === b? Fd: b} função Z (a, b, d) {var c, e, f = a.isPure = Qg (a, d); switch (a.type) {case q.Programa: c =! 0; r (a.body, função (a) {Z (a.expression,
b, f); c = c && a.expression.constant}); a.constant = c; break; case q.Literal: a.constant =! 0; a.toWatch = []; break; case q.UnaryExpression: Z (a.argument, b, f); a.constant = a.argument.constant; a.toWatch = a.argument.toWatch; break; case q.BinaryExpression: Z (a.left, b, f); Z ( a.right, b, f); a.constant = a.left.constant && a.right.constant; a.toWatch = a.left.toWatch.concat (a.right.toWatch); break; case q.LogicalExpression: Z (a.left, b, f); Z (a.right, b, f); a.constant = a.left.constant && a.right.constant; a.toWatch = a.constant? []: [a]; break; case q.ConditionalExpression: Z (a.test,
b, f); Z (a.alternate, b, f); Z (a. subsequente, b, f); a.constant = a.test.constant && a.alternate.constant && a.consequent.constant; a.toWatch = a .constant? []: [a]; break; case q.Identificador: a.constant =! 1; a.toWatch = [a]; break; case q.MemberExpression: Z (a.object, b, f); a.computado && Z (a.property, b, f); a.constant = a.object.constant && (! a.computed || a.property.constant); a.toWatch = a.constant? []: [a] ; break; case q.CallExpression: c = d = a.filter?! b (a.callee.name). $ stateful:! 1; e = []; r (a.arguments, function (a) {Z ( a, b, f); c = c && a.constant; e.push.apply (e,
a.toWatch)}); a.constant = c; a.toWatch = d? e: [a]; break; case q.AssignmentExpression: Z (a.left, b, f); Z (a.right, b , f); a.constant = a.left.constant && a.right.constant; a.toWatch = [a]; break; case q.ArrayExpression: c =! 0; e = []; r (elementos, função (a) {Z (a, b, f); c = c && a.constant; e.push.apply (e, a.toWatch)}); a.constant = c; a.toWatch = e; break; case q .ObjectExpression: c =! 0; e = []; r (a.properties, function (a) {Z (a.value, b, f); c = c && a.value.constant; e.push.apply (e , a.value.toWatch); a.computed && (Z (a.key, b,! 1), c = c && a.key.constant, e.push.apply (e,
A.key.toWatch))}); a.constant = c; a.toWatch = e; break; case q.ThisExpression: a.constant =! 1; a.toWatch = []; break; case q.LocalsExpression: a.constant =! 1, a.toWatch = []}} função Gd (a) {if (1 === comprimento.a) {a = a [0] .expression; var b = a.toWatch; return 1 ! == b.length? b: b [0]! == a? b: void 0}} função Hd (a) {retorna a.type === qIdentificador || a.type === q. Identificação da função MemberExpression} (a) {if (1 === a.body.length && Hd (a.body [0] .expression)) return {type: q.AssignmentExpression, left: a.body [0] .expression, right : {type: q.NGValueParameter}, operador: "="}}
função Jd (a) {this. $ filter = a} função Kd (a) {this. $ filter = a} função Mb (a, b, d) {this.ast = new q (a, d); this. astCompiler = d.csp? new Kd (b): nova função Jd (b)} Ac (a) {retorna B (a.valorOf)? a.valueOf (): Rg.call (a)} função Vf () { var a = T (), b = {"true" :! 0, "false" :! 1, "null": null, indefinido: void 0}, d, c; this.addLiteral = function (a, c) {b [a] = c}; this.setIdentifierFns = função (a, b) {d = a; c = b; retorna isso}; isso. $ get = ["$ filter", função (e) {function f (b, c) {var d, f; switch (typeof b) {case "string": retorna f = b = b.trim (), d = a [f], d || (d = new Nb (G ),
d = (novo Mb (d, e, G)). parse (b), a [f] = p (d)), s (d, c); case "function": return s (b, c); padrão: return s (E, c)}} função g (a, b, c) {return null == a || null == b? a === b: "objeto"! == typeof a || ( a = Ac (a), "objeto"! == tipo de a || c)? a === b || a! == a && b! == b:! 1} função k (a, b, c, d , e) {var f = entradas d, h; se (1 === comprimento f) {var k = g, f = f [0]; retornar a. $ watch (função (a) {var b = f (a); g (b, k, f.isPure) || (h = d (a, nulo 0, nulo 0, [b]), k = b && Ac (b)); retorno h}, b, c , e)} para (var l = [], m = [], n = 0, p = comprimento; n <p; n ++) l [n] = g, m [n] = nulo; retorno a. $ watch (função (a) {for (var b =
! 1, c = 0, e = f.length; c <e; c ++) {var k = f [c] (a); if (b || (b =! G (k, l [c], f [c] .isPure))) m [c] = k, l [c] = k && Ac (k)} b && (h = d (a, nulo 0, nulo 0, m)); retorne h}, b, c , e)} função h (a, b, c, d, e) {função f () {h (m) && k ()} função g (a, b, c, d) {m = u && d? d [0 ]: n (a, b, c, d); h (m) && a. $$ postDigest (f); retorno s (m)} var h = d.literal? l: w, k, m, n = d . $$ interceptado || d, s = d. $$ interceptor || Ta, u = entradas.d & n! entradas; g.literal = d.literal; g.constant = d.constant; g.inputs = d .inputs; p (g); return k = a. $ watch (g, b, c, e)} função l (a) {var b =! 0; r (a, função (a) {w (a) || (b =! 1)}); retornar b}
função m (a, b, c, d) {var e = a. $ watch (função (a) {e (); retorno d (a)}, b, c); retorno e} função p (a) { a.constant? a. $$ watchDelegate = m: a.oneTime? a. $$ watchDelegate = h: a.inputs && (a. $$ watchDelegate = k); retorna a} função n (a, b) {função c (d) {return b (a (d))} c. $ stateful = a. $ stateful || b. $ stateful; c. $$ pure = a. $$ pure && b. $$ pure; return c} função s (a, b) {if (! b) retorna a; a. $$ interceptor && (b = n (a. $$ interceptor, b), a = a. $$ interceptado); var c =! 1, d = função (d, e, f, g) {d = c && g? g [0]: a (d, e, f, g); retorno b (d)}; d. $$ interceptado = a; d. $$ interceptor =
b; d.literal = a.literal; d.oneTime = a.oneTime; d.constant = a.constant; b. $ stateful || (c =! a.inputs, d.inputs = a.inputs? a. entradas: [a], b. $$ pure || (entradas.input = entradas.inputs.map (função (a) {retornar a.isPure === Fd? função (b) {retornar a (b)}: a}))); return p (d)} var G = {csp: Aa (). noUnsafeEval, literais: Ia (b), isIdentifierStart: B (d) && d, isIdentifierContinue: B (c) && c}; f. $$ getAst = function (a) {var b = new Nb (G); return (new Mb (b, e, G)). getAst (a) .ast}; return f}]} função Xf () {var a =! 0; this. $ get = ["$ rootScope", "$ exceptionHandler", função (b, d) {retorna Ld (função (a) {b. $ evalAsync (a)},
d, a)}]; this.errorOnUnhandledRejections = function (b) {return w (b)? (a = b, this): a}} function Yf () {var a =! 0; this. $ get = [ "$ browser", "$ exceptionHandler", function (b, d) {return Ld (function (a) {b.defer (a)}, d, a)}]; this.errorOnUnhandledRejections = function (b) {return w (b)? (a = b, isto): a}} função Ld (a, b, d) {função c () {retorna nova e} função e () {var a = this.promise = new f; this.resolve = function (b) {h (a, b)}; this.reject = function (b) {m (a, b)}; this.notify = function (b) {n (a, b)} } função f () {this. $$ state = {status: 0}} função g () {para (;! w &&
x.length;) {var a = x.shift (); if (! a.pur) {a.pur =! 0; var c = valor.a, c = "Rejeição possivelmente não tratada:" + ("função" === typeof c? c.toString (). replace (/ \ {[\ s \ S] * $ /, ""): z (c)? "undefined": "string"! == typeof c? Ou seja (c, void 0): c); cc (a.value)? b (a.value, c): b (c)}}} função k (c) {! d || c.pending || 2! == c.status || c.pur || (0 === w && 0 === x.length && a (g), x.push (c)) ;! c.processScheduled && c.pending && (c.processScheduled =! 0, ++ w, a (function () {var e, f, k; k = c.pending; c.processScheduled =! 1; c.pending = void 0; tente {for (var l = 0, n = k. length; l <n; ++ l) {c.pur =
! 0; f = k [l] [0]; e = k [l] [estado c]; tente {B (e)? H (f, e (valor c))): 1 === c. status? h (f, c.valor): m (f, c.value)} captura (p) {m (f, p), p &&! 0 === p. $$ passToExceptionHandler && b (p)}}} finalmente {--w, d && 0 === w && a (g)}}))} função h (a, b) {a. $$ state.status || (b === a? p (a, v ("qcycle ", b)): l (a, b))} função l (a, b) {função c (b) {g || (g =! 0, l (a, b))} função d (b) {g || (g =! 0, p (a, b))} função e (b) {n (a, b)} var f, g =! 1; tente {if (D (b) || B (b)) f = b.then; B (f)? (a. $$ state.status = -1, f.call (b, c, d, e)) :( a. $$ state.value = b, a. $$ state.status = 1, k (a. $$ state))} catch (h) {d (h)}} função m (a,
b) {a. $$ state.status || p (a, b)} função p (a, b) {a. $$ state.value = b; a. $$ state.status = 2; k (a . $$ state)} função n (c, d) {var e = c. $$ state.pending; 0> = c. $$ state.status && e && e.length && a (function () {for (var a, c, f = 0, g = comprimento; f <g; f ++) {c = e [f] [0]; a = e [f] [3]; tente {n (c, B (a)? A (d ): d)} catch (h) {b (h)}}})} função s (a) {var b = new f; m (b, a); return b} função G (a, b, c) {var d = null; tente {B (c) && (d = c ())} catch (e) {return s (e)} retorne d && B (d.then)? d.then (function () {return b (a)}, s): b (a)} função t (a, b, c, d) {var e = new f; h (e, a); return e.then (b, c,
d)} function q (a) {if (! B (a)) throw v ("norslvr", a); var b = new f; a (function (a) {h (b, a)}, function ( a) {m (b, a)}); return b} var v = F ("$ q", TypeError), w = 0, x = []; S (f.prototype, {then: function (a, b, c) {if (z (a) && z (b) && z (c)) retorna isso; var d = novo f; isso. $$ state.pending = this. $$ state.pending || []; this . $$ state.pending.push ([d, a, b, c]); 0 <isto. $$ state.status && k (este. $$ estado); return d}, "catch": function (a) { retorna this.then (null, a)}, "finalmente": function (a, b) {retorna this.then (function (b) {retorna G (b, y, a)}, function (b) {retorna G (b, s, a)},
b)}}); var y = t; q.prototype = f.prototype; q.defer = c; q.reject = s; q.when = t; q.resolve = y; q.all = function (a ) {var b = new f, c = 0, d = H (a)? []: {}; r (a, função (a, e) {c ++; t (a) .then (function (a) { d [e] = a; - c || h (b, d)}, função (a) {m (b, a)})}); 0 === c && h (b, d); return b} ; q.race = function (a) {var b = c (); r (a, function (a) {t (a) .then (b.resolve, b.reject)}); return b.promise}; return q} função hg () {this. $ get = ["$ window", "$ timeout", função (a, b) {var d = a.requestAnimationFrame || a.webkitRequestAnimationFrame, c = a.cancelAnimationFrame || a.webkitCancelAnimationFrame ||
a.webkitCancelRequestAnimationFrame, e = !! d, f = e? function (a) {var b = d (a); função de retorno () {c (b)}}: function (a) {var c = b (a , 16.66,! 1); return function () {b.cancel (c)}}; f.supported = e; return f}]} function Wf () {function a (a) {function b () {this. $$ watchers = isto. $$ nextSibling = isto. $$ childHead = isto. $$ childTail = null; isto. $$ ouvintes = {}; isto. $$ listenerCount = {}; isto. $$ watchersCount = 0; $ id = ++ pb; this. $$ ChildScope = null; this. $$ suspendido =! 1} b.prototype = a; return b} var b = 10, d = F ("$ rootScope"), c = nulo, e = nulo; this.digestTtl =
function (a) {argument.length && (b = a); return b}; this. $ get = ["$ exceptionHandler", "$ parse", "$ browser", função (f, g, k) {função h (a) {a.currentScope. $$ destroyed =! 0} função l (a) {9 === Ca && (a. $$ childHead && l (a. $$ childHead), a. $$ nextSibling && l (a. $$ nextSibling)); a. $ parent = a. $$ nextSibling = a. $$ prevSibling = a. $$ childHead = a. $$ childTail = a. $ root = a. $$ watchers = null} função m () {this. $ id = ++ pb; this. $$ phase = this. $ parent = this. $$ watchers = this. $$ nextSibling = this. $$ prevSibling = this. $$ childHead = this. $$ childTail = null; este. $ root =
$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ - $ $ - $ - $ - $ - - - - - - - - - - - - - - -. } função p (a) {if (fase v. $$) lance d ("inprog", fase v. $$); fase v. $$ = a} função n (a, b) {faça ​​a. $$ watchersCount + = b; while (a = a. $ parent)} função s (a, b, c) {faça ​​a. $$ listenerCount [c] - = b, 0 === a. $$ listenerCount [c] && delete a. $$ listenerCount [c]; while (a = a. $ parent)} função G () {} função t () {for (; y.length;) tente {y.shift () ()} catch ( a) {f (a)} e = nulo} função q () {nulo === e && (e = k.defer (function () {v. $ apply (t)},
null, "$ applyAsync"))} m.prototype = {construtor: m, $ new: função (b, c) {var d; c = c || isto; b? (d = novo m, d. $ root = this. $ root) :( this. $$ ChildScope || (this. $$ ChildScope = a (this)), d = novo isso. $$ ChildScope); d. $ parent = c; d. $$ prevSibling = c. $$ childTail; c. $$ childHead? (c. $$ childTail. $$ nextSibling = d, c. $$ childTail = d): c. $$ childHead = c. $$ childTail = d; ( b || c! == isto) && d. $ on ("$ destroy", h); retorna d}, $ watch: function (a, b, d, e) {var f = g (a); b = B (b)? B: E; se (f. $$ watchDelegate) retornar f. $$ watchDelegate (isto, b, d, f, a); var h = isso, k = h. $$ observadores, l =
{fn: b, last: G, get: f, exp: e || a, eq: !! d}; c = nulo; k || (k = h. $$ observadores = [], k. $$ () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () ()) -1), a <k. $$ digestWatchIndex && k. $$ digestWatchIndex -); c = null}}, $ watchGroup: function (a, b) {function c () {h =! 1; tente {k? ( k =! 1, b (e, e, g)): b (e, d, g)} finalmente {para (var f = 0; f <comprimento.a; f ++) d [f] = e [f] }} var d = Array (a.length), e = Array (a.length), f = [], g = this, h =! 1, k =! 0; if (! a.length) {var l =! 0; g. $ EvalAsync (função () {l && b (e, e, g)}); função de retorno () {l =
! 1}} if (1 === a.length) retorna isso. $ Watch (a [0], função (a, c, f) {e [0] = a; d [0] = c; b ( e, a === c? e: d, f)}); r (a, função (a, b) {var d = g. $ watch (a, função (a) {e [b] = a; h || (h =! 0, g. $ evalAsync (c))}); f.push (d)}); função de retorno () {for (; f.length;) f.shift () ()} }, $ watchCollection: function (a, b) {function c (a) {e = a; var b, d, g, h; if (! z (e)) {if (D (e)) if (ya (e)) para (f! == n && (f = n, t = f.length = 0, l ++), a = e.length, t! == a && (l ++, f.length = t = a), b = 0; b <a; b ++) h = f [b], g = e [b], d = h! == h && g! == g, d || h === g || (l ++, f [b] = g); else {f! == p && (f = p = {}, t = 0, l ++); a = 0; para (b em e) ta.call (e,
b) && (a ++, g = e [b], h = f [b], b em f? (d = h! == h && g! == g, d || h === g || (l ++, f [b] = g)) :( t ++, f [b] = g, l ++)); if (t> a) para (b em l ++, f) ta.call (e, b) || (t- -, exclua f [b])} else f! == e && (f = e, l ++); retorne l}} c. $$ pure = g (a) .literal; c. $ stateful =! c. $$ puro; var d = isto, e, f, h, k = 1 <comprimento b, l = 0, m = g (a, c), n = [], p = {}, s =! 0, t = 0; retorne isso. $ Watch (m, função () {s? (S =! 1, b (e, e, d)): b (e, h, d); if (k) if (D ( e)) if (ya (e)) {h = Matriz (comprimento e); para (var a = 0; a <comprimento e;; ++) h [a] = e [a]} mais para (a em h = {}, e) ta.call (e, a) && (h [a] = e [a]); caso contrário, h = e})}, $ digest: function () {var a,
g, h, l, m, n, s, r = b, q, y = w.length? v: isto, N = [], z, A; p ("$ digest"); k. $$ checkUrlChange (); this === v && null! == e && (k.defer.cancel (e), t ()); c = null; faça {s =! 1; q = y; para (n = 0; n < w.length; n ++) {try {A = w [n], l = A.fn, l (A.scope, A.locals)} catch (C) {f (C)} c = nulo} w.length = 0; a: faça {if (n =! Q. $$ suspenso && q. $$ observadores) para (n. $$ digestWatchIndex = n.length; n. $$ digestWatchIndex -;) tente {if (a = n [n. $$ digestWatchIndex]) if (m = a.get, (g = m (q))! == (h = a.último) &&! (a.eq? va (g, h): X ( (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (b) g: h, q), 5> r && (z = 4-r, N [z] ||
(N [z] = []), N [z]. Push ({msg: B (a.exp)? "Fn:" + (a.exp.name || a.exp.toString ()): a .exp, newVal: g, oldVal: h})); else if (a === c) {s =! 1; break a}} catch (E) {f (E)} if (! (n =! q. $$ suspenso && q. $$ watchersCount && q. $$ childHead || q! == y && q. $$ nextSibling)) para (; q! == y &&! (n = q. $$ nextSibling);) q = q. $ parent} while (q = n); if ((s || w.length) &&! r -) lança v. $$ phase = null, d ("infdig", b, N);} while (s || w.length); para (v. $$ phase = null; J <x.length;) tente {x [J ++] ()} catch (D) {f (D)} x.length = J = 0 ; k. $$ checkUrlChange ()}, $ suspend: function () {this. $$ suspendido =! 0}, $ isSuspended: function () {retorna isso. $$ suspendido},
$ resume: function () {isto. $$ suspenso =! 1}, $ destroy: function () {se (! isto. $$ destruído) {var a = isto. $ pai; isto. $ broadcast ("$ destroy "); este. $$ destruído =! 0; este === v && k. $$ applicationDestroyed (); n (isto, -este. $$ watchersCount); para (var b neste. $$ listenerCount) s (este , this. $$ listenerCount [b], b); a && a. $$ childHead === this && (a. $$ childHead = this. $$ nextSibling); a && a. $$ childTail === this && (a. $$ childTail = this. $$ prevSibling); this. $$ prevSibling && (this. $$ prevSibling. $$ nextSibling = this. $$ nextSibling); this. $$ nextSibling && (este. $$ nextSibling. $$ prevSibling =
Este $ $$ prevSibling); este. $ destroy = this. $ digest = this. $ apply = this. $ evalAsync = this. $ applyAsync = E; this. $ on = this. $ watch = this. $ watchGroup = function () {return E}; this. $$ listeners = {}; this. $$ nextSibling = null; l (this)}}, $ eval: function (a, b) {return g (a) (this, b )}, $ evalAsync: function (a, b) {v. $$ phase || w.length || k.defer (function () {w.length && v. $ digest ()}, null, "$ evalAsync") ; w.push ({escopo: this, fn: g (a), locais: b})}, $$ postDigest: function (a) {x.push (a)}, $ apply: function (a) {try {p ("$ apply"); tente {retornar isso. $ eval (a)} finalmente {v. $$ phase =
null}} catch (b) {f (b)} finalmente {try {v. $ digest ()} catch (c) {throw f (c), c;}}}, $ applyAsync: function (a) {function b () {c. $ eval (a)} var c = isto; a && y.push (b); a = g (a); q ()}, $ on: function (a, b) {var c = this . $$ listeners [a]; c || (este. $$ listeners [a] = c = []); c.push (b); var d = this; faça d. $$ listenerCount [a] || (d. $$ listenerCount [a] = 0), d. $$ listenerCount [a] ++; while (d = d. $ parent); var e = this; return function () {var d = c.indexOf (b); - 1! == d && (excluir c [d], s (e, 1, a))}}, $ emit: function (a, b) {var c = [], d, e = this , g =! 1, h = {nome: a, targetScope: e, stopPropagation: function () {g =
! 0}, preventDefault: function () {h.defaultPrevented =! 0}, defaultPrevented:! 1}, k = db ([h], argumentos, 1), l, m; do {d = e. $$ ouvintes [a] || c; h.currentScope = e; l = 0; for (m = comprimento.d; l <m; l ++) se (d [l]) tente {d [l] .apply (null, k )} catch (n) {f (n)} else d.splice (l, 1), l -, m -; se (g) quebrar; e = e. $ parent} enquanto (e); h. currentScope = null; return h}, $ broadcast: function (a, b) {var c = this, d = this, e = {name: a, targetScope: this, preventDefault: function () {e.defaultPrevented =! 0 }, defaultPrevented:! 1}; if (! this. $$ listenerCount [a]) retorna e; for (var g = db ([e], argumentos,
1), h, k; c = d;) {e.currentScope = c; d = c. $$ ouvintes [a] || []; h = 0; para (k = comprimento.d; h <k; h ++) if (d [h]) tente {d [h] .apply (null, g)} catch (l) {f (l)} else d.splice (h, 1), h -, k-- ; if (! (d = c. $$ listenerCount [a] && c. $$ childHead || c! == this && c. $$ nextSibling)) para (; c! == this &&! (d = c. $$ nextSibling );) c = c. $ pai} e.currentScope = nulo; retorno e}}; var v = novo m, w = v. $$ asyncQueue = [], x = v. $$ postDigestQueue = [], y = v. $$ applyAsyncQueue = [], J = 0; retornar v}]} função Le () {var a = / ^ \ s * (https? | s? ftp | mailto | tel | arquivo): /, b = / ^ \ s * ((https? | ftp | arquivo | blob): | dados: imagem \ /) /;
this.aHrefSanitizationWhitelist = function (b) {return w (b)? (a = b, this): a}; this.imgSrcSanitizationWhitelist = function (a) {return w (a)? (b = a, this): b }; this. $ get = function () {função de retorno (d, c) {var e = c? b: a, f = ga (d && d.trim ()). href; return "" === f || f.match (e)? d: "inseguro:" + f}}} função Sg (a) {if ("self" === a) retorna a; if (A (a)) {if (-1 < a.indexOf ("***")) lança Ea ("iwcard", a); a = Md (a) .place (/ \\\ * \\\ * / g, ". *"). replace ( /\\\*/g,"[^:/.?&;)*"); retornar novo RegExp ("^" + a + "$")} if (ab (a)) retornar novo RegExp ("^" + a.source + "$"); lança Ea ("imatcher");
} função Nd (a) {var b = []; w (a) && r (a, função (a) {b.push (Sg (a))}); return b} função $ f () {this.SCE_CONTEXTS = V; var a = ["self"], b = []; this.resourceUrlWhitelist = function (b) {argument.length && (a = Nd (b)); retorna a}; this.resourceUrlBlacklist = function (a) {argument.length && (b = Nd (a)); return b}; this. $ get = ["$ injector", "$$ sanitizeUri", função (d, c) {function e (a, b) {var c; "self" === a? (c = Bc (b, Od)) || (C.document.baseURI? c = C.document.baseURI: (Na || (Na = C.document.createElement ( "a"), Na.href = ".", Na = Na.cloneNode (! 1)), c = Na.href),
c = Bc (b, c)): c = !! a.exec (b.href); retorna c} função f (a) {var b = função (a) {isto. $$ desembrulharTrustedValue = function () { retorne a}}; a && (b.prototype = new a); b.prototype.valueOf = function () {retorne isso. $$ unwrapTrustedValue ()}; b.prototype.toString = function () {retorne isso. $$ desempacotarTrustedValue (). toString ()}; retornar b} var g = função (a) {lançar Ea ("inseguro");}; d.has ("$ sanitize") && (g = d.get ("$ sanitize ")); var k = f (), h = {}; h [V.HTML] = f (k); h [V.CSS] = f (k); h [V.MEDIA_URL] = f (k ); h [V.URL] = f (h [V.MEDIA_URL]); h [V.JS] = f (k); h [V.RESOURCE_URL] =
f (h [V.URL]); return {trustAs: function (a, b) {var c = h.hasOwnProperty (a)? h [a]: null; if (! c) lança Ea ("icontext", a, b); if (null === b || z (b) || "" === b) retorna b; if ("string"! == typeof b) lança Ea ("itype", a) ; retorna new c (b)}, getTrusted: function (d, f) {if (null === f || z (f) || "" === f) retorna f; var k = h.hasOwnProperty ( d)? h [d]: null; if (k &&f instanceof k) return f. $$ unwrapTrustedValue (); B (f. $$ unbrapTrustedValue) && (f = f. $$ unbrapTrustedValue ()); if (d = == V.MEDIA_URL || d === V.URL) retorna c (f.toString (), d === V.MEDIA_URL); if (d === V.RESOURCE_URL) {var k =
ga (f.toString ()), n, s, r =! 1; n = 0; for (s = a.length; n <s; n ++) se (e (a [n], k)) {r =! 0; break} if (r) for (n = 0, s = comprimento b; n <s; n ++) if (e (b [n], k)) {r =! 1; break} if ( r) return f; throw Ea ("insecurl", f.toString ());} if (d === V.HTML) retorna g (f); throw Ea ("inseguro");}, valueOf: function ( a) {retorna uma instância de k? a. $$ desempacotamentoValor (): a}}}]} função Zf () {var a =! 0; this.enabled = função (b) {argumentos.comprimento && (a = !! b); retorna a}; this. $ get = ["$ parse", "$ sceDelegate", função (b, d) {if (a && 8> Ca) lança Ea ("iequirks"); var c = ja (V c.isEnabled = function () {retorna a};
c.trustAs = d.trustAs; c.getTrusted = d.getTrusted; c.valueOf = d.valueOf; a || (c.trustAs = c.getTrusted = função (a, b) {return b}, c.valueOf = Ta); c.parseAs = function (a, d) {var e = b (d); return e.literal && e.constant? E: b (d, function (b) {return c.getTrusted (a, b) })}; var e = c.parseAs, f = c.getTrusted, g = c.trustAs; r (V, função (a, b) {var d = K (b); c [("parse_as _" + d ) .replace (Cc, wb)] = function (b) {return e (a, b)}; c [("get_trusted _" + d) .replace (Cc, wb)] = function (b) {return f ( a, b)}; c [("trust_as _" + d). substituir (Cc, wb)] = função (b) {retornar g (a, b)}});
return c}]} função ag () {isto. $ get = ["$ janela", "$ documento", função (a, b) {var d = {}, c =! ((! a.nw || ! a.nw.process) && a.chrome && (a.chrome.app && a.chrome.app.runtime ||! a.chrome.app && a.chrome.runtime && a.chrome.runtime.id)) && a.history && a.history.pushState, e = fa ((/ android (\ d +) /. exec (K ((a.navigator || {}). userAgent)) || []) [1]), f = / Boxee / i.test (( a.navigator || {}). userAgent), g = b [0] || {}, k = g.body && g.body.style, h =! 1, l =! 1; k && (h = !! ( "transição" em k || "webkitTransição" em k), l = !! ("animação" em k || "webkitAnimation" em k)); return {history:! (! c ||
4> e || f), hasEvent: function (a) {if ("input" === a && Ca) retorna! 1; if (z (d [a])) {var b = g.createElement ("div" ); d [a] = "on" + a em b} retorna d [a]}, csp: Aa (), transições: h, animações: l, android: e}}]} função bg () {this. $ get = ia (function (a) {return new Tg (a)})} function Tg (a) {function b () {var a = e.pop (); retorna a && a.cb} função d (a) { for (var b = e.length-1; 0 <= b; - b) {var c = e [b]; if (c.type === a) retorna e.splice (b, 1), c .cb}} var c = {}, e = [], f = this.ALL_TASKS_TYPE = "$$ all $$", g = this.DEFAULT_TASK_TYPE = "$$ default $$"; this.completeTask = function (e ,
h) {h = h || g; tente {e ()} finalmente {var l; l = h || g; c [l] && (c [l] -, c [f] -); l = c [h]; var m = c [f]; se (! m ||! l) para (l = m? d: b; m = l (h);) tente {m ()} captura (p ) {a.error (p)}}}; this.incTaskCount = function (a) {a = a || g; c [a] = (c [a] || 0) +1; c [f] = (c [f] || 0) +1}; this.notifyWhenNoPendingTasks = function (a, b) {b = b || f; c [b]? e.push ({type: b, cb: a}) : a ()}} function dg () {var a; this.httpOptions = function (b) {return b? (a = b, this): a}; this. $ get = ["$ exceptionHandler", "$ templateCache "," $ http "," $ q "," $ sce ", function (b, d, c, e, f) {function g (k, h) {g.totalPendingRequests ++; if (! A (k) ||
z (d.get (k))) k = f.getTrustedResourceUrl (k); var l = c.defaults && c.defaults.transformResponse; H (l)? l = l.filter (função (a) {return a! = = vc}): l === vc && (l = nulo); return c.get (k, S ({cache: d, transformResponse: l}, a)). finalmente (function () {g.totalPendingRequests-- }). then (function (a) {return d.put (k, a.data)}, function (a) {h || (a = Ug ("carregamento", k, a.status, a.statusText) , b (a)); return e.reject (a)})} g.totalPendingRequests = 0; return g}]} function eg () {this. $ get = ["$ rootScope", "$ browser", " $ location ", function (a, b, d) {return {findBindings: function (a,
b, d) {a = a.getElementsByClassName ("ng-binding"); var g = []; r (a, função (a) {var c = ca.element (a) .data ("$ binding") ; c && r (c, função (c) {d? (novo RegExp ("(^ | \\ s)" + Md (b) + "(\\ s | \\ || $)")). test (c ) && g.push (a): - 1! == c.indexOf (b) && g.push (a)})}); return g}, findModels: function (a, b, d) {for (var g = ["ng -", "data-ng -", "ng \\:"], k = 0; k <comprimento g; ++ k) {var h = a.querySelectorAll ("[" + g [k ] + "model" + (d? "=": "* =") + '"' + b + '"]'); se (comprimento) retornar h}}, getLocation: function () {return d. url ()}, setLocation: function (b) {b! == d.url () && (d.url (b), a. $ digest ())},
whenStable: function (a) {b.notifyWhenNoOutstandingRequests (a)}}}]} function fg () {this. $ get = ["$ rootScope", "$ browser", "$ q", "$$ q", "$ exceptionHandler", função (a, b, d, c, e) {função f (f, h, l) {B (f) || (l = h, h = f, f = E); var m = Ha.call (argumentos, 3), p = w (l) &&! L, n = (p? C: d) .defer (), s = n.promise, r; r = b.defer (function ( ) {try {n.resolve (f.apply (null, m))} catch (b) {n.reject (b), e (b)} finalmente {delete g [s. $$ timeoutId]} p || a. $ apply ()}, h, "$ timeout"); s. $$ timeoutId = r; g [r] = n; retornar s} var g = {}; f.cancel = function (a) {if (! a) return! 1; if (! a.hasOwnProperty ("$$ timeoutId")) lança Vg ("badprom");
Se (! g.hasOwnProperty (a. $$ timeoutId)) retornar! 1; a = a. $$ timeoutId; var c = g [a], d = c.promise; d. $$ state && (d. $$ state.pur =! 0); c.reject ("cancelado"); delete g [a]; retorne b.defer.cancel (a)}; retorne f}]} função ga (a) {if (! A ( a) retorna a; Ca && (aa.setAttribute ("href", a), a = aa.href); aa.setAttribute ("href", a); a = aa.hostname;! Wg && - 1 <a. indexOf (":") && (a = "[" + a + "]"); return {href: aa.href, protocolo: aa.protocol? aa.protocol.replace (/: $ /, ""): " ", host: aa.host, pesquisa: aa.search? aa.search.replace (/ ^ \? /," "):" ", hash: aa.hash? aa.hash.replace (/ ^ # /,
""): "", nome do host: a, porta: aa.port, nome do caminho: "/" === aa.pathname.charAt (0)? aa.pathname: "/" + aa.pathname}} função Jg ( a) {var b = [Od] .concat (a.map (ga)); função de retorno (a) {a = ga (a); return b.some (Bc.bind (null, a))}} function Bc (a, b) {a = ga (a); b = ga (b); retorna a.protocol === b.protocol && a.host === b.host} função gg () {this. $ Get = ia (C)} função Pd (a) {função b (a) {tente {retornar decodeURIComponent (a)} captura (b) {retorne a}} var d = a [0] || {}, c = {} , e = ""; função de retorno () {var a, g, k, h, l; tente {a = d.cookie || ""} catch (m) {a = ""} if (a! == e) para (e = a, a =
e.split (";"), c = {}, k = 0; k <comprimento.k ++) g = a [k], h = g.indexOf ("="), 0 <h && (l = b (g.substring (0, h)), z (c [l]) && (c [l] = b (g.substring (h + 1)))); retornar c}} função kg () {this . $ get = Pd} função dd (a) {função b (d, c) {if (D (d)) {var e = {}; r (d, função (a, c) {e [c] = b (c, a)}); return e} return a.factory (d + "Filter", c)} this.register = b; this. $ get = ["$ injector", function (a) {return function ( b) {retornar a.get (b + "Filtro")}}]; b ("moeda", Qd); b ("data", Rd); b ("filtro", Xg); b ("json", Yg); b ("limitTo", Zg); b ("minúsculas", $ g); b ("número", Sd); b ("orderBy",
Td); b ("maiúsculas", ah)} função Xg () {função de retorno (a, b, d, c) {if (! Ya (a)) {if (null == a) retorna a; throw F ("filter") ("notarray", a);} c = c || "$"; var e; switch (Dc (b)) {case "function": break; case "boolean": case "null" : case "number": case "string": e =! 0; case "object": b = bh (b, d, c, e); break; padrão: retorne a} return Array.prototype.filter.call ( a, b)}} função bh (a, b, d, c) {var e = D (a) && d em a;! 0 === b? b = va: B (b) || (b = função (a, b) {if (z (a)) retorna! 1; if (null === a || null === b) retorna a === b; if (D (b) || D (a ) &&! bc (a)) return! 1; a = K ("" + a); b = K ("" +
b); return-1! == a.indexOf (b)}); return function (f) {return e &&! D (f)? Fa (f, a [d], b, d,! 1): Fa (f, a, b, d, c)}} função Fa (a, b, d, c, e, f) {var g = Dc (a), k = Dc (b); if ("string" = == k && "!" === b.charAt (0)) return! Fa (a, b.substring (1), d, c, e); if (H (a)) retorna a.some (function ( a) {retornar Fa (a, b, d, c, e)}); switch (g) {case "objeto": var h; if (e) {para (h em a) if (h.charAt && "$ "! == h.charAt (0) && Fa (a [h], b, d, c,! 0)) return! 0; return f?! 1: Fa (a, b, d, c,! 1) } if ("objeto" === k) {para (h em b) if (f = b [h] ,! B (f) &&! z (f) && (g = h === c,! Fa (g? a: a [h], f, d, c, g, g))) return! 1; return! 0} return d (a,
b); case "function": return! 1; default: return d (a, b)}} função Dc (a) {return null === a? "null": tipo de a} função Qd (a) {var b = a.NUMBER_FORMATS; função de retorno (a, c, e) {z (c) && (c = b.CURRENCY_SYM); z (e) && (e = b.PATTERNS [1] .maxFrac); var f = c? / \ u00A4 / g: / \ s * \ u00A4 \ s * / g; return null == a? a: Ud (a, b.PATTERNS [1], b.GROUP_SEP, b.DECIMAL_SEP, e). substituir (f, c)}} função Sd (a) {var b = a.NUMBER_FORMATS; função de retorno (a, c) {return null == a? a: Ud (a, b.PATTERNS [0], b. Função GROUP_SEP, b.DECIMAL_SEP, c)}} ch (a) {var b = 0, d, c, e, f, g; -1 <(c = a.indexOf (Vd)) &&
(a = a.replace (Vd, "")); 0 <(e = a.search (/ e / i))? (0> c && (c = e), c + = + a.slice (e + 1 () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () ()) = (g = a.length)) d = [0], c = 1; else {for (g -; a.charAt (g) === Ec;) g -; c- = e; d = []; para (f = 0; e <= g; e ++, f ++) d [f] = + a.charAt (e)} c> Wd && (d = d.splice (0, Wd-1), b = c-1, c = 1); return {d: d, e: b, i: c}} função dh (a, b, d, c) {var e = ad, f = e.length-ai; b = z (b)? Math.min (Math.max (d, f), c): + b; d = b + ai; c = e [d]; if (0 <d) {e.splice (Math .max (ai, d)); para (var g = d; g <e.length; g ++) e [g] = 0} mais para (f = Math.max (0, f), ai =
1, e.length = Math.max (1, d = b + 1), e [0] = 0, g = 1; g <d; g ++) e [g] = 0; se (5 <= c) if (0> d-1) {for (c = 0; c> d; c -) e.unshift (0), a.i ++; e.unshift (1); a.i ++} else e [d- 1] ++; for (; f <Math.max (0, b); f ++) e.push (0); if (b = e.reduceRight (função (a, b, c, d) {b + = a ; d [c] = b% 10; retorna Math.floor (b / 10)}, 0)) e.unshift (b), a.i ++} função Ud (a, b, d, c, e) {se (! A (a) &&! W (a) || isNaN (a)) return ""; var f =! IsFinite (a), g =! 1, k = Math.abs (a) + "", h = ""; if (f) h = "\ u221e"; else {g = ch (k); dh (g, e, b.minFrac, b.maxFrac); h = gd; k = gi; e = ge ; f = []; para (g = h.reduzir (função (a, b) {retornar a &&! b},
! 0); 0> k;) h.shift (0), k ++; 0 <k? F = h.splice (k, h.length) :( f = h, h = [0]); k = [ ]; for (h.length> = b.lgSize && k.unshift (h.splice (-b.lgSize, h.length) .join ("")); h.length> b.gSize;) k.unshift (h .splice (-b.gSize, h.length) .join ("")); h.length && k.unshift (h.join ("")); h = k.join (d); f.length && (h + = c + f.join ("")); e && (h + = "e +" + e)} retornar 0> a &&! g? b.negPre + h + b.negSuf: função b.posPre + h + b.posSuf} Ob (a, b, d, c) {var e = ""; se (0> a || c && 0> = a) c? A = -a + 1: (a = -a, e = "-") ; for (a = "" + a; a.length <b;) a = Ec + a; d && (a = a.substr (a.length-b)); retorne e + a} função ea (a,
b, d, c, e) {d = d || 0; função de retorno (f) {f = f ["get" + a] (); if (0 <d || f> -d) f + = d ; 0 === f && - 12 === d && (f = 12); return Ob (f, b, c, e)}} função kb (a, b, d) {função de retorno (c, e) {var f = c ["obter" + a] (), g = ub ((d? "STANDALONE": "") + (b? "CURTO": "") + a); retornar e [g] [f] }} função Xd (a) {var b = (nova Data (a, 0,1)). getDay (); retorna nova data (a, 0, (4> = b? 5: 12) -b)} função Yd (a) {função de retorno (b) {var d = Xd (b.getFullYear ()); b = + nova data (b.getFullYear (), b.getMonth (), b.getDate () + (4- b.getDay ())) - + d; b = 1 + Math.round (b / 6048E5); return Ob (b, a)}} função Fc (a, b) {return 0> =
a.getFullYear ()? b.ERAS [0]: b.ERAS [1]} função Rd (a) {função b (a) {var b; if (b = a.match (d)) {a = new Data (0); var f = 0, g = 0, k = b [8]? A.setUTCFullYear: a.setFullYear, h = b [8]? A.setUTCHours: a.setHours; b [9] && ( f = fa (b [9] + b [10]), g = fa (b [9] + b [11])); k.call (a, fa (b [1]), fa (b [2 ]) - 1, fa (b [3])); f = fa (b [4] || 0) -f; g = fa (b [5] || 0) -g; k = fa (b [ 6] || 0); b = Math.round (1E3 * parseFloat ("0." + (B [7] || 0))); h.call (a, f, g, k, b)} return a} var d = / ^ (\ d {4}) -? (\ d \ d) -? (\ d \ d) (?: T (\ d \ d) (? ::? (\ d \ d ) (? ::? (\ d \ d) (?: \. (\ d +))?)?)? (Z | ([+ -]) (\ d \ d):? (\ d \ d) )?)? $ /; função de retorno (c,
d, f) {var g = "", k = [], h, l; d = d || "dataMédia"; d = a.DATETIME_FORMATS [d] || d; A (c) && (c = eh .test (c)? fa (c): b (c)); W (c) && (c = new Date (c)); if (! ha (c) ||! isFinite (c.getTime ()) () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () ()) () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () d = null); var m = c.getTimezoneOffset (); f && (m = ec (f, m), c = fc (c, f,! 0)); r (k, função (b) {h = gh [b]; g + = h? h (c, a.DATETIME_FORMATS, m): "''" === b? "'": b.replace (/ (^' | '$) / g, "") .replace (/ '' / g, "'")}); return g}} function Yg () {return function (a, b) {z (b) && (b = 2); return eb (a, b )}} função Zg () {função de retorno (a,
b, d) {b = Infinito === Math.abs (Number (b))? Number (b): fa (b); if (X (b)) retorna a; W (a) && (a = a .toString ()); if (! ya (a)) retorna a; d =! d || isNaN (d)? 0: fa (d); d = 0> d? Math.max (0, a.length A soma de dois números inteiros é igual a 0, e o outro é igual a 0. d + b), d)}} função Gc (a, b, d) {retorno A (a)? a.slice (b, d): Ha.call (a, b, d)} função Td (a) {função b (b) {retorno b.map (função (b) {var c = 1, d = Ta; if (B (b)) d = b; caso contrário, se (A (b)) {if ("+ "=== b.charAt (0) ||" - "=== b.charAt (0)) c =" - "=== b.charAt (0)? - 1: 1, b = b.substring (1); if (""! == b && (d = a (b), d.constant)) var e =
d (), d = função (a) {retornar a [e]}} retornar {get: d, decrescente: c}})} função d (a) {alternar (tipo de a) {case "number": case " booleano ": case" string ": return! 0; padrão: return! 1}} função c (a, b) {var c = 0, d = a.type, h = b.type; if (d === h) {var h = a.valor, l = b.value; "string" === d? (h = h.toLowerCase (), l = l.toLowerCase ()): "objeto" === d && ( D (h) && (h = a.índice), D (l) && (l = b.índice)); h! == l && (c = h <l? -1: 1)} else c = "indefinido "=== d? 1:" indefinido "=== h? -1:" nulo "=== d? 1:" nulo "=== h? -1: d <h? -1: 1; retornar c} função de retorno (a, f, g, k) {if (null == a) retorna a; if (! ya (a)) lança F ("orderBy") ("notarray",
a); H (f) || (f = [f]); 0 === comprimento f && (f = ["+"]); var h = b (f), l = g? -1: 1 , m = B (k)? k: c; a = Array.prototype.map.call (a, function (a, b) {return {value: a, tieBreaker: {value: b, type: "number", index: b}, predicateValues: h.map (function (c) {var e = c.get (a); c = typeof e; if (null === e) c = "null"; else if ("object "=== c) a: {if (B (e.valorOf) && (e = e.valueOf (), d (e))) quebra a; bc (e) && (e = e.toString (), d (e))} retorna {valor: e, digite: c, índice: b}})}}); a.sort (função (a, b) {para (var d = 0, e = comprimento; d <e; d ++) {var f = m (a.predicateValues ​​[d], b.predicateValues ​​[d]); se (f) retornar f *
h [d] .descendente * l} return (m (a.tieBreaker, b.tieBreaker) || c (a.tieBreaker, b.tieBreaker)) * l}); retorna a = a.map (função (a) {return a.value})}} function Ra (a) {B (a) && (a = {link: a}); a.restrict = a.restrict || "AC"; return ia (a)} function Pb (a, b, d, c, e) {isto. $$ controla = []; isto. $ Erro = {}; isto. $$ sucesso = {}; isto. $ Pendente = vazio 0; isto. $ nome = e (b.name || b.ngForm || "") (d); isso. $ dirty =! 1; isso. $ valid = isso. $ pristine =! 0; isso. $ submit = this. $ inválido =! 1; this. $$ parentForm = lb; this. $$ element = a; this. $$ animate = c; Zd (this)} função Zd (a) {a. $$ classCache =
{}; a. $$ classCache [$ d] =! (a. $$ classCache [mb] = a. $$ element.hasClass (mb))} função ae (a) {função b (a, b, c ) {c &&! a. $$ classCache [b]? (a. $$ animate.addClass (a. $$ elemento, b), a. $$ classCache [b] =! 0) :! c && a. $$ classCache [b] && (a. $$ animate.removeClass (a. $$ elemento, b), a. $$ classCache [b] =! 1)} função d (a, c, d) {c = c? " - "+ Vc (c," - "):" "; b (a, mb + c,! 0 === d); b (a, $ d + c,! 1 === d)} var c = a.set, e = a.unset; a.clazz.prototype. $ setValidity = função (a, g, k) {z (g)? (isso. $ pendente || (isso. $ pendente = {}) , c (this. $ pendente, a, k)) :( this. $ pendente && e (this. $ pendente,
a, k), seja (isso. $ pendente) && (isso. $ pendente = vazio 0)); Ga (g)? g? (e (esse. $ erro, a, k), c (isso. $$ sucesso, a, k)) :( c (este. $ erro, a, k), e (este. $$ sucesso, a, k)) :( e (esse. $ erro, a, k), e ( Este. $$ sucesso, a, k)); Este. $ pendente? (b (este, "ng-pendente",! 0), este. $ válido = este. $ inválido = vazio 0, d (este, " ", null)) :( b (isto," ng-pendente ",! 1), isto. $ valid = be (isto. $ erro), isto. $ inválido =! isto. $ valid, d (isto," ", isto. $ válido)); g = isto. $ pendente && isto. $ pendente [a]? void 0: isto. $ erro [a] ?! 1: isto. $$ sucesso [a] ?! 0: nulo; d (this, a, g); this. $$ parentForm. $ setValidity (a,
g, this)}} function be (a) {if (a) for (var b in a) if (a.hasOwnProperty (b)) return! 1; return! 0} function Hc (a) {a. $ formatadores .push (função (b) {retornar a. $ isEmpty (b)? b: b.toString ()})} função Sa (a, b, d, c, e, f) {var g = K (b [ 0] .type); if (! E.android) {var k =! 1; b.on ("início da composição", função () {k =! 0}); b.on ("compositionupdate", função (a ) {if (z (a.data) || "" === a.data) k =! 1}); b.on ("fim de composição", função () {k =! 1; l ()}) } var h, l = function (a) {h && (f.defer.cancel (h), h = null); if (! k) {var e = b.val (); a = a && a.type; "senha "=== g || d.ngTrim &&
"false" === d.ngTrim || (e = U (e)); (c. $ viewValue! == e || "" === e && c. $$ hasNativeValidators) && c. $ setViewValue (e, a )}}; if (e.hasEvent ("input")) b.on ("input", l); else {var m = função (a, b, c) {h || (h = f.defer ( function () {h = null; b &&b.value === c || l (a)}))}; b.on ("keydown", função (a) {var b = a.keyCode; 91 === b || 15 <b && 19> b || 37 <= b && 40> = b || m (a, este, este.valor)}); if (e.hasEvent ("paste")) b.on ("paste cut drop ", m)} b.on (" alteração ", l); if (ce [g] && c. $$ hasNativeValidators && g === d.type) b.on (" keydown wheel mousedown ", function (a) { if (! h) {var b = this.validity,
c = b.badInput, d = b.typeMismatch; h = f.defer (function () {h = null; b.badInput === c && b.typeMismatch === d || l (a)})}}) ; c. $ render = function () {var a = c. $ isEmpty (c. $ viewValue)? "": c. $ viewValue; b.val ()! == a && b.val (a)}} função Qb (a, b) {função de retorno (d, c) {var e, f; se (ha (d)) retornar d; if (A (d)) {'"' === d.charAt (0) && '"' === d.charAt (d.length-1) && (d = d.substring (1, d.length-1)); if (hh.test (d)) retorna new Date (d); a.lastIndex = 0; if (e = a.exec (d)) retorna e.shift (), f = c? {aaaa: c.getFullYear (), MM: c.getMonth () + 1, dd: c .getDate (), HH: c.getHours (), mm: c.getMinutes (),
ss: c.getSeconds (), sss: c.getMilliseconds () / 1E3}: {aaaa: 1970, MM: 1, dd: 1, HH: 0, mm: 0, ss: 0, sss: 0}, r (e, função (a, c) {c <comprimento b && (f [b [c]] = + a)}), e = nova data (f.aaaa, f.MM-1, f.dd, f .HH, f.mm, f.ss || 0,1E3 * f.sss || 0), 100> f.aaaa && e.setFullYear (f.aaaa), e} retornar NaN}} função nb (a, b, d, c) {função de retorno (e, f, g, k, h, l, m, p) {função n (a) {retorna a &&! (a.getTime && a.getTime ()! == a.getTime () )} função s (a) {return w (a) &&! ha (a)? r (a) || vazio 0: a} função r (a, b) {var c = k. $ options.getOption (" fuso horário "); v && v! == c && (b = Sc (b, ec (v))); var e = d (a,
b) ;! isNaN (e) && c && (e = fc (e, c)); return e} Ic (e, f, g, k, a); Sa (e, f, g, k, h, l) ; var t = "time" === a || "datetimelocal" === a, q, v; k. $ parsers.push (função (c) {se (k. $ isEmpty (c)) retornar nulo; if (b.test (c)) retorna r (c, q); k. $$ parserName = a}); k. $ formatters.push (function (a) {if (a &&! ha (a)) throw ob ("datefmt", a); if (n (a)) {q = a; var b = k. $ options.getOption ("fuso horário"); b && (v = b, q = fc (q, b ,! 0)); var d = c; t && A (k. $ Options.getOption ("timeSecondsFormat")) && (d = c.replace ("ss.sss", k. $ Options.getOption ("timeSecondsFormat")). substituir (/: $ /, "")); a = m ("data") (a,
d, b); t && k. $ options.getOption ("timeStripZeroSeconds") && (a = a.replace (/ (? :: 00)? (?: \. 000)? $ /, "")); retornar um } v = q = nulo; retorna ""}); if (w (g.min) || g.ngMin) {var x = g.min || p (g.ngMin) (e), B = s ( x); k. $ validators.min = função (a) {return! n (a) || z (B) || d (a)> = B}; g. $ observe ("min", função (a ) {a! == x && (B = s (a), x = a, k. $ validate ())})} if (w (g.max) || g.ngMax) {var y = g.max || p (g.ngMax) (e), J = s (y); k. $ validators.max = function (a) {return! n (a) || z (J) || d (a) < = J}; g. $ Observe ("max", função (a) {a! == y && (J = s (a), y = a, k. $ Validate ())})}}} função Ic ( a, b, d,
c, e) {(c. $$ hasNativeValidators = D (b [0] .validez)) && c. $ parsers.push (função (a) {var d = b.prop ("validade") || {}; if (d.badInput || d.typeMismatch) c. $$ parserName = e; caso contrário, retorne a})} função de (a) {a. $ parsers.push (função (b) {if (a. $ isEmpty ( b)) retorna null; if (ih.test (b)) retorna parseFloat (b); a. $$ parserName = "number"}); a. $ formatters.push (função (b) {if (! a. $ isEmpty (b)) {if (! W (b)) joga ob ("numfmt", b); b = b.toString ()} retorna b})} função na (a) {w (a) &&! W (a) && (a = parseFloat (a)); return X (a)? Void 0: a} função Jc (a) {var b = a.toString (),
d = b.indexOf ("."); return-1 === d? -1 <a && 1> a && (a = / e - (\ d +) $ /. exec (b))? Number (a [1] ): 0: b.length-d-1} função ee (a, b, d) {a = Número (a); var c = (a | 0)! == a, e = (b | 0)! == b, f = (d | 0)! == d; se (c || e || f) {var g = c? Jc (a): 0, k = e? Jc (b): 0, h = f J Jc (d): 0, g = Math.max (g, k, h), g = Math.pow (10, g); a * = g; b * = g; d * = g; c && (a = Math.round (a)); e && (b = Math.round (b)); f && (d = Math.round (d))} return 0 === (ab)% d} função fe ( a, b, d, c, e) {if (w (c)) {a = a (c); if (! a.constant) throw ob ("constexpr", d, c); retorne a (b) } retornar e} função Kc (a, b) {função d (a, b) {if (! a ||! a.length) return [];
if (! b ||! b.length) retorna a; var c = [], d = 0; a: for (; d <comprimento a; d ++) {for (var e = a [d], m = 0; m <comprimento.b; m ++) if (e === b [m]) continue a; c.push (e)} retorne c} função c (a) {if (! A) retorne a; var b = a; H (a)? b = a.map (c) .join (""): D (a)? b = Object.keys (a) .filter (função (b) {return a [b]} ) .join (""): A (a) || (b = a + ""); retorno b} a = "ngClass" + a; var e; return ["$ parse", função (f) {return { restringir: "AC", link: função (g, k, h) {função l (a, b) {var c = []; r (a, função (a) {if (0 <b || p [a ]) p [a] = (p [a] || 0) + b, p [a] === + (0 <b) && c.push (a)}); retorne c.join ("")} função m (a) {if (a ===
b) {var c = s, c = l (c && c.split (""), 1); h. $ addClass (c)} mais c = s, c = l (c && c.split (""), - 1 ), h. $ removeClass (c); n = a} var p = k.data ("$ classCounts"), n =! 0, s; p || (p = T (), k.data ("$ classCounts ", p));" ngClass "! == a && (e || (e = f (" $ index ", função (a) {retorna a & 1}))), g. $ watch (e, m)); g. $ watch (f (h [a], c), função (a) {if (n === b) {var c = s && s.split (""), e = a && a.split (""), Se a resposta ajudou de alguma forma, por favor, marque como resposta, caso a sua dúvida não tenha sido solucionada, por favor, poste novamente. f)} s = a})}}}]} função qd (a, b, d, c, e, f) {retornar {restringir: "A", compilar: função (g, k) {var h = a (k [c]); função de retorno (a,
c) {c.on (e, função (c) {var e = function () {h (a, {$ event: c})}; if (fase b. $$) if (f) a. $ evalAsync (e); else tente {e ()} catch (g) {d (g)} else a. $ apply (e)})}}}}} função Rb (a, b, d, c, e, f, g, k, h) {this. $ modelValue = this. $ viewValue = Number.NaN; this. $$ rawModelValue = void 0; this. $ validators = {}; this. $ asyncValidators = {}; this. $ parsers = []; this. $ formatters = []; this. $ viewChangeListeners = []; this. $ untouched =! 0; this. $ touched =! 1; this. $ pristine =! 0; essa. $ dirty =! 1; este. $ Válido =! 0; este. $ Inválido =! 1; este. $ Erro = {}; este. $$ sucesso = {}; este. $ Pendente =
void 0; this. $ name = h (nome.de || "",! 1) (a); this. $$ parentForm = lb; this. $ options = Sb; this. $$ updateEvents = ""; this . $$ updateEventHandler = this. $$ updateEventHandler.bind (this); this. $$ parsedNgModel = e (d.ngModel); this. $$ parsedNgModelAssign = this. $$ parsedNgModel.assign; this. $$ ngModelGet = this . $$ parsedNgModel; this. $$ ngModelSet = this. $$ parsedNgModelAssign; this. $$ pendingDebounce = null; this. $$ parserValid = void 0; this. $$ parserName = "parse"; this. $$ currentValidationRunId = 0; este. $$ escopo = a; este. $$ rootScope = a. $ Root; este. $$ attr = d;
Este elemento $$ $$ = c; este. $$ animar = f; este. $$ timeout = g; este. $$ parse = e; este. $$ q = k; este. $$ exceptionHandler = b; Zd ( jh (this)} function jh (a) {a. $$ scope. $ watch (function (b) {b = a. $$ ngModelGet (b); b === a. $ modelValue || a $ modelValue! == a. $ modelValue && b! == b || a. $$ setModelValue (b); retorno b})} função Lc (a) {isto. $$ opções = a} função ge (a, b ) {r (b, função (b, c) {w (a [c]) || (a [c] = b)})} função Oa (a, b) {a.prop ("selecionado", b ); a.attr ("selected", b)} função he (a, b, d) {if (a) {A (a) && (a = new RegExp ("^" + a + "$")); se (! a.test) jogar F ("ngPattern") ("noregexp",
b, a, za (d)); retorna a}} função Tb (a) {a = fa (a); retorna X (a)? - 1: a} var Wb = {objectMaxDepth: 5, urlErrorParamsEnabled:! 0 }, ou seja = / ^ \ / (. +) \ / ([az] *) $ /, ta = Object.prototype.hasOwnProperty, K = function (a) {return A (a)? a.toLowerCase (): a}, ub = function (a) {return A (a)? a.toUpperCase (): a}, Ca, x, rb, Ha = []. fatia, Fg = []. emenda, kh = []. push, la = Object.prototype.toString, Pc = Object.getPrototypeOf, pa = F ("ng"), ca = C.angular || (C.angular = {}), kc, pb = 0; Ca = C .document.documentMode; var X = Number.isNaN || função (a) {return a! == a}; E. $ inject = []; Ta. $ inject =
[]; var ve = / ^ \ [objeto (?: Uint8 | Uint8Clamped | Uint16 | Uint32 | Int8 | Int16 | Int32 | Float32 | Float64) Matriz] $ /, U = função (a) {retornar A (a)? a.trim (): a}, Md = function (a) {return a.replace (/([-()[\}{}+?*.$^ |,: # <! \\]) / g , "\\ $ 1"). Replace (/ \ x08 / g, "\\ x08")}, Aa = function () {if (! W (Aa.rules)) {var a = C.document.querySelector ( "[ng-csp]") || C.document.querySelector ("[data-ng-csp]"); se (a) {var b = a.getAttribute ("ng-csp") || a.getAttribute ("data-ng-csp"); Aa.rules = {noUnsafeEval:! b || -1! == b.indexOf ("no-unsafe-eval"), noInlineStyle:! b || -1! ==
b.indexOf ("no-inline-style")}} else {a = Aa; tente {new Function (""), b =! 1} catch (d) {b =! 0} a.rules = {noUnsafeEval : b, noInlineStyle:! 1}}} retorna Aa.rules}, qb = function () {if (w (qb.name _)) retorna qb.name_; var a, b, d = Qa.length, c, e ; para (b = 0; b <d; ++ b) if (c = Qa [b], a = C.document.querySelector ("[" + c.replace (":", "\\:") + "jq]")) {e = a.getAttribute (c + "jq"); break} retorna qb.name_ = e}, xe = /: / g, Qa = ["ng -", "data-ng- "," ng: "," x-ng - "], Be = função (a) {var b = a.currentScript; if (! b) retorna! 0; if (! (instância de C.HTMLScriptElement || b instanceof C.SVGScriptElement)) return! 1;
b = b.attributes; return [b.getNamedItem ("src"), b.getNamedItem ("href"), b.getNamedItem ("xlink: href")]. every (function (b) {if (! b) return! 0; if (! b.value) return! 1; var c = a.createElement ("a"); c.href = b.value; if (a.location.origin === c.origin) return ! 0; switch (c.protocol) {case "http:": case "https:": case "ftp:": case "blob:": case "arquivo:": case "data:": return! 0; padrão: return! 1}})} (C.document), Ee = / [AZ] / g, Wc =! 1, Pa = 3, Ke = {full: "1.7.9", maior: 1, menor: 7, ponto: 9, codeName: "erradicação da poluição"}; Y.expando = "ng339"; var Ka = Y.cache =
{}, pg = 1; Y._dados = função (a) {retorne this.cache [a [this.expando]] || {}}; var lg = / - ([az]) / g, lh = / ^ -ms - /, Ab = {mouseleave: "mouseout", mouseenter: "mouseover"}, nc = F ("jqLite"), og = / ^ <([\ w -] +) \ s * \ /? > (?: <\ / \ 1> |) $ /, mc = / <| & #? \ W +; /, mg = / <([\ w: -] +) /, ng = / <(?! area | br | col | embed | hr | img | input | link | meta | param) (([\ w: -] +) [^>] *) \ /> / gi, oa = {opção: [1, '<select multiple = "multiple">', "</select>"], thead: [1, "<table>", "</table>"], col: [2, "<table> <colgroup> "," </colgroup> </table> "], tr: [2," <table> <tbody> "," </tbody> </table> "], td: [3," <table> < tbody> <tr> ",
"</tr> </tbody> </table>"], _ padrão: [0, "", ""]}; oa.optgroup = oa.option; oa.tbody = oa.tfoot = oa.colgroup = oa .caption = oa.thead; oa.th = oa.td; var ug = C.Node.prototype.contains || function (a) {return !! (this.compareDocumentPosition (a) & 16)}, Wa = Y. prototype = {ready: fd, toString: function () {var a = []; r (esta, função (b) {a.push ("" + b)})); return "[" + a.join (" , ") +"] "}, eq: function (a) {return 0 <= a? x (this [a]): x (this [this.length + a])}, length: 0, push: kh , sort: []. sort, splice: []. splice}, Gb = {}; r ("vários selecionados selecionados desabilitados, readOnly required open" .split ("),
função (a) {Gb [K (a)] = a}); var md = {}; r ("entrada opção de seleção textarea botão detalhes do formulário". divisão (""), função (a) {md [a] =! 0}); var td = {ngMinlength: "minlength", ngMaxlength: "maxlength", ngMin: "min", ngMax: "max", ngPattern: "padrão", ngStep: "step"}; r ({ data: rc, removeData: qc, hasData: function (a) {for (var b em Ka [a.ng339]) return! 0; return! 1}, cleanData: function (a) {for (var b = 0, d = a.length; b <d; b ++) qc (a [b]), id (a [b])}}, função (a, b) {Y [b] = a}); r ({data : rc, herdatedData: Eb, escopo: function (a) {return x.data (a, "$ scope") || Eb (a.parentNode ||
a, ["$ isolateScope", "$ scope"])}, isolateScope: function (a) {return x.data (a, "$ isolateScope") || x.data (a, "$ isolateScopeNoTemplate")}, controller: jd, injector: function (a) {return Eb (a, "$ injector")}, removeAttr: function (a, b) {a.removeAttribute (b)}, hasClass: Bb, css: function (a, b, d) {b = xb (b.replace (lh, "ms -")); if (w (d)) a.style [b] = d; caso contrário, retorne a.style [b]}, attr: função (a, b, d) {var c = a.nodeType; if (c! == Pa && 2! == c && 8! == c && a.getAttribute) {var c = K (b), e = Gb [c]; if (w (d)) null === d ||! 1 === d && e? a.removeAttribute (b): a.setAttribute (b,
e? c: d); else return a = a.getAttribute (b), e && null! == a && (a = c), null === a? void 0: a}}, prop: function (a, b, d) {if (w (d)) a [b] = d; caso contrário, retorne a [b]}, texto: function () {function a (a, d) {if (z (d)) {var c = a.nodeType; return 1 === c || c === Pa? a.textContent: ""} a.textContent = d} a. $ dv = ""; retorna a} (), val: function (a , b) {if (z (b)) {if (a.multiple && "select" === ua (a)) {var d = []; r (a.options, function (a) {a.selected && d. push (a.value || a.text)}); return d} retorna a.value} a.value = b}, html: function (a, b) {if (z (b)) retorna a.innerHTML; yb (a,! 0); a.innerHTML = b},
vazio: kd}, função (a, b) {Y.prototype [b] = function (b, c) {var e, f, g = this.length; if (a! == kd && z (2 === a .length && a! == Bb && a! == jd? b: c)) {if (D (b)) {for (e = 0; e <g; e ++) if (a === rc) a (this [e ], b); caso contrário, para (f em b) a (isto [e], f, b [f]); retorne} e = a. $ dv; g = z (e)? Math.min (g, 1): g; para (f = 0; f <g; f ++) {var k = a (isto [f], b, c); e = e? E + k: k} retorna e} para (e = 0; e <g; e ++) a (este [e], b, c); retorne}}); r ({removeData: qc, on: function (a, b, d, c) {if (w ( c)) jogue nc ("onargs"); if (lc (a)) {c = zb (a,! 0); var e = c.eventos, f = c.handle; f || (f = c. identificador = rg (a, e)); c = 0 <= b.indexOf ("")?
b.split (""): [b]; para (var g = comprimento c, k = função (b, c, g) {var k = e [b]; k || (k = e [b] = [], k.specialHandlerWrapper = c, "$ destroy" === b || g || a.addEventListener (b, f)); k.push (d)}; g -;) b = c [ g], Ab [b]? (k (Ab [b], tg), k (b, vazio 0,! 0)): k (b)}}, desativado: id, um: função (a, b, d) {a = x (a); a.on (b, função e () {a.off (b, d); a.off (b, e)}); a.on (b, d)} , replaceWith: function (a, b) {var d, c = a.parentNode; yb (a); r (novo Y (b), função (b) {d? c.insertBefore (b, d.nextSibling): c.replaceChild (b, a); d = b})}, filhos: função (a) {var b = []; r (a.childNodes, função (a) {1 ===
a.nodeType && b.push (a)}); return b}, content: function (a) {return a.contentDocument || a.childNodes || []}, anexa: function (a, b) {var d = a .nodeType; if (1 === d || 11 === d) {b = novo Y (b); for (var d = 0, c = comprimento.b; d <c; d ++) a.appendChild ( b [d])}}, precede: function (a, b) {if (1 === a.nodeType) {var d = a.firstChild; r (novo Y (b), função (b) {a. insertBefore (b, d)})}}, wrap: function (a, b) {var d = x (b) .eq (0) .clone () [0], c = a.parentNode; c && c.replaceChild ( d, a); d.appendChild (a)}, remove: Fb, desanexa: function (a) {Fb (a,! 0)}, depois de: function (a, b) {var d = a, c = a .parentNode;
if (c) {b = new Y (b); for (var e = 0, f = comprimento.b; e <f; e ++) {var g = b [e]; c.inserirBefore (g, d.nextSibling ); d = g}}}, addClass: Db, removeClass: Cb, toggleClass: function (a, b, d) {b && r (b.split ("")), função (b) {var e = d; z ( e) && (e =! Bb (a, b)); (e? Db: Cb) (a, b)})}, pai: função (a) {return (a = a.parentNode) && 11! == a.nodeType? a: null}, próximo: function (a) {retorne a.nextElementSibling}, encontre: function (a, b) {retorne a.getElementsByTagName? a.getElementsByTagName (b): []}, clone: ​​pc , triggerHandler: function (a, b, d) {var c, e, f = b.type || b, g = zb (a); if (g = (g = g && g.events) &&
g [f]) ​​c = {preventDefault: function () {this.defaultPrevented =! 0}, isDefaultPrevented: function () {return! 0 === this.defaultPrevented}, stopImmediatePropagation: function () {this.immediatePropagationStopped =! 0}, isImmediatePropagationStopped: function () {return! 0 === this.immediatePropagationStopped}, stopPropagation: E, tipo: f, destino: a}, b.type && (c = S (c, b)), b = ja (g), e = d? [c] .concat (d): [c], r (b, função (b) {c.isImmediatePropagationStopped () || b.apply (a, e)})}}, função (a, b) {Y.prototype [b] = function (b, c, e) {for (var f, g = 0, k = this.length; g <
k; g ++) z (f)? (f = a (isto [g], b, c, e), w (f) && (f = x (f))): oc (f, a (isto [g ], b, c, e)); return w (f)? f: this}}); Y.prototype.bind = Y.prototype.on; Y.prototype.unbind = Y.prototype.off; var mh = Object.create (null); nd.prototype = {_ idx: function (a) {a! == this._lastKey && (this._lastKey = a, this._lastIndex = this._keys.indexOf (a)); retorne isso. _lastIndex}, _ transformKey: function (a) {return X (a)? mh: a}, get: function (a) {a = this._transformKey (a); a = this._idx (a); if (-1 ! == a) retorna this._values ​​[a]}, possui: function (a) {a = this._transformKey (a); return-1! == this._idx (a)},
set: function (a, b) {a = this._transformKey (a); var d = this._idx (a); - 1 === d && (d = this._lastIndex = this._keys.length); this. _keys [d] = a; this._values ​​[d] = b}, delete: function (a) {a = this._transformKey (a); a = this._idx (a); if (-1 === a ); return! 1; this._keys.splice (a, 1); this._values.splice (a, 1); this._lastKey = NaN; this._lastIndex = -1; return! 0}}; var Hb = nd , jg = [function () {this. $ get = [function () {return Hb}]}], wg = / ^ ([^ (] +?) => /, xg = / ^ [^ (] * \ (\ s * ([^)] *) \) / m, nh = /, /, oh = / ^ \ s * (_?) (\ S +?) \ 1 \ s * $ /, vg = / ((\ / \ /.*$) | (\ / \ * [\ s \ S] *? \ * \ /)) / mg, Ba = F ("$ injector");
fb. $$ annotate = function (a, b, d) {var c; if ("function" === tipo de a) {if (! (c = a. $ injetar)) {c = []; if ( a.length) {if (b) lance A (d) && d || (d = a.name || yg (a)), Ba ("strictdi", d); b = od (a); r (b [1] .split (nh), função (a) {a.replace (oh, função (a, b, d) {c.push (d)})})} a. $ Inject = c}} else H (a)? (b = a.length-1, sb (a [b], "fn"), c = a.slice (0, b)): sb (a, "fn",! 0); return c}; var je = F ("$ animate"), zf = function () {this. $ get = E}, Af = function () {var a = new Hb, b = []; this. $ get = ["$$ AnimateRunner", "$ rootScope", função (d, c) {função e (a, b, c) {var d =! 1; b && (b = A (b)? B.split ("" ):
H (b)? B: [], r (b, função (b) {b && (d =! 0, a [b] = c)})); retornar d} função f () {r (b, função (b) {var c = a.get (b); se (c) {var d = zg (b.attr ("classe"))), e = "", f = ""; r (c, função ( a, b) {a! == !! d [b] && (a? e + = (e.length? "": "") + b: f + = (f.length? "": "") + b )}); r (b, função (a) {e && Db (a, e); f && Cb (a, f)}); a.delete (b)}}); b.length = 0} retorno {ativado: E , on: E, off: E, pino: E, push: function (g, k, h, l) {l && l (); h = h || {}; h.from && g.css (h.from); h .to && g.css (h.to); if (h.addClass || h.removeClass) if (k = h.addClass, l = h.removeClass, h = a.get (g) || {}, k = e (h, k,! 0), l = e (h, l,! 1),
k || l) a.set (g, h), b.push (g), 1 === b.length && c. $$ postDigest (f); g = new d; g.complete (); return g} }}]}, xf = ["$ fornecer", função (a) {var b = isto, d = nulo, c = nulo; isto. $$ registrationAnimations = Object.create (null); this.register = function ( c, d) {if (c && "."! == c.charAt (0)) throw je ("notcsel", c); var g = c + "- animação"; b. $$ RegisteredAnimations [c.substr ( 1)] = g; a.fábrica (g, d)}; this.customFilter = function (a) {1 === argument.length && (c = B (a)? A: null); return c}; this .classNameFilter = function (a) {if (1 === argument.length && (d = uma instância do RegExp?
a: null) && / [(\ s | \ /)] ng-animate [(\ s | \ /)] /. test (d.toString ())) throw d = null, je ("nongcls", " ng-animate "); return d}; this. $ get = [" $$ animateQueue ", função (a) {função b (a, c, d) {if (d) {var e; a: {for ( e = 0; e <comprimento.d; e ++) {var f = d [e]; if (1 === f.nodeType) {e = f; interrompa a}} e = nulo 0}! e || e .parentNode || e.previousElementSibling || (d = nulo)} d? depois (a): c.prepend (a)} retorno {on: a.on, off: a.off, pin: a.pin , ativado: a.enabled, cancel: function (a) {a.cancel && a.cancel ()}, insira: function (c, d, h, l) {d = d && x (d); h = h && x (h); d = d || h.parent (); b (c, d, h); retorna a.push (c,
"enter", ra (l))}, move: function (c, d, h, l) {d = d && x (d); h = h && x (h); d = d || h.parent (); b (c, d, h); retorna a.push (c, "move", ra (l))}, deixa: function (b, c) {retorna a.push (b, "sai", ra (c) , function () {b.remove ()})}, addClass: function (b, c, d) {d = ra (d); d.addClass = hb (d.addclass, c); retorna a.push ( b, "addClass", d)}, removeClass: function (b, c, d) {d = ra (d); d.removeClass = hb (d.removeClass, c); retorne a.push (b, "removeClass ", d)}, setClass: function (b, c, d, f) {f = ra (f); f.addClass = hb (f.addClass, c); f.removeClass = hb (f.removeClass, d ); retornar a.push (b, "setClass",
f)}, animar: função (b, c, d, f, m) {m = ra (m); m.from = m.from? S (m.from, c): c; m.to = m .to? S (m.to, d): d; m.tempClasses = hb (m.tempClasses, f || "ng-inline-animate"); retorna a.push (b, "animate", m)} }}]}], Cf = function () {this. $ Get = ["$$ rAF", function (a) {function b (b) {d.push (b); 1 <d.length || a (função () {para (var a = 0; a <comprimento d; a ++) d [a] (); d = []})} var d = []; função de retorno () {var a =! 1 ; b (function () {a =! 0}); return function (d) {a? d (): b (d)}}}]}, Bf = function () {this. $ get = ["$ q "," $ sniffer "," $$ animateAsyncRun "," $$ isDocumentHidden "," $ timeout ", função (a,
b, d, c, e) {function f (a) {this.setHost (a); var b = d (); this._doneCallbacks = []; this._tick = function (a) {c ()? e (a, 0,! 1): b (a)}; this._state = 0} f.chain = function (a, b) {function c () {if (d === comprimento.a) b (! 0); else a [d] (function (a) {! 1 === a? B (! 1) :( d ++, c ())})} var d = 0; c ()}; f.all = função (a, b) {função c (f) {e = e && f; ++ d === a.length && b (e)} var d = 0, e =! 0; r (a, função (a) { a.done (c)})}; f.prototype = {setHost: function (a) {this.host = a || {}}, concluído: function (a) {2 === this._state? a ( ): this._doneCallbacks.push (a)}, progresso: E, getPromise: function () {if (! this.promise) {var b =
this; this.promise = a (function (a, c) {b.done (function (b) {! 1 === b? c (): a ()})})} retorne this.promise} e, em seguida, : function (a, b) {retorna this.getPromise (). then (a, b)}, "catch": function (a) {retorna this.getPromise () ["catch"] (a)}, "finalmente ": function (a) {return this.getPromise () [" finalmente "] (a)}, pausa: function () {this.host.pause && this.host.pause ()}, resume: function () {this. host.resume && this.host.resume ()}, final: function () {this.host.end && this.host.end (); this._resolve (! 0)}, cancele: function () {this.host.cancel && this. host.cancel (); this._resolve (! 1)},
complete: function (a) {var b = this; 0 === b._state && (b._state = 1, b._tick (function () {b._resolve (a)}))}, _ resolve: function (a ) {2! == this._state && (r (this._doneCallbacks, function (b) {b (a)}), this._doneCallbacks.length = 0, this._state = 2)}}; return f}]} , yf = function () {this. $ get = ["$$ rAF", "$ q", "$$ AnimateRunner", função (a, b, d) {função de retorno (b, e) {function f ( ) (a (function () {g.addClass && (b.addClass (g.addClass), g.addClass = null); g.removeClass && (b.removeClass (g.removeClass), g.removeClass = null); g. para && (b.css (g.to), g.to = nulo); k ||
h.complete (); k =! 0}); return h} var g = e || {}; g. $$ preparado || (g = Ia (g)); g.cleanupStyles && (g.from = g .to = null); g.from && (b.css (g.from), g.from = null); var k, h = new d; return {start: f, end: f}}}]}, $ = F ("$ compilar"), tc = nova função () {}; Xc. $ Injetar = ["$ fornecer", "$$ sanitizeUriProvider"]; Jb.prototype.isFirstChange = function () {retornar this.previousValue === tc}; var pd = / ^ ((?: x | data) [: \ -_]) / i, por exemplo, = / [: \ -_] + (.) / g, vd = F (" $ controller "), ud = / ^ (\ S +) (\ s + as \ s + ([\ w $] +))? $ /, Jf = function () {this. $ get = [" $ document ", função (a) {função de retorno (b) {b?! b.nodeType &&
b instância de x && (b = b [0]): b = a [0] .body; return b.offsetWidth + 1}}]}, wd = "application / json", wc = {"Content-Type": wd + "; charset = utf-8"}, Hg = / ^ \ [| ^ \ {(?! \ {) /, Ig = {"[": /] $ /, "{": /} $ /}, Gg = / ^ \)] \} ',? \ N /, Kb = F ("$ http"), Ma = ca. $ interpolateMinErr = F ("$ interpolate"); Ma.throwNoconcat = function (a) { jogar Ma ("noconcat", a);}; Ma.interr = function (a, b) {retornar Ma ("interr", a, b.toString ())}; var Lg = F ("$ interval") , Sf = function () {this. $ Get = function () {function a (a) {var b = function (a) {b.data = a; b.called =! 0}; b.id = a; retornar b} var b = ca.callbacks,
d = {}; return {createCallback: function (c) {c = "_" + (b. $$ counter ++). toString (36); var e = "angular.callbacks." + c, f = a (c ); d [e] = b [c] = f; retorno e}, foi chamado: função (a) {retorno d [a]. chamado}, getResponse: função (a) {retorno d [a] .dados}, removeCallback: function (a) {delete b [d [a] .id]; delete d [a]}}}}, ph = / ^ ([^? #] *) (\? ([^ #] *) )? (# (. *))? $ /, Mg = {http: 80, https: 443, ftp: 21}, jb = F ("$ location"), Ng = / ^ \ s * [\\ / ] {2,} /, qh = {$$ absUrl: "", $$ html5:! 1, $$ substitua:! 1, $$ componha: function () {para (var a = this. $$ caminho, b = isto. $$ hash, d = ye (isto. $$ pesquisa), b = b?
"#" + hc (b): "", a = a.split ("/"), c = a.length; c -;) a [c] = hc (a [c] .replace (/% 2F / g, "/")); this. $$ url = a.join ("/") + (d? "?" + D: "") + b; isso. $$ absUrl = this. $$ normalizeUrl (this. $$ url); this. $$ urlUpdatedByLocation =! 0}, absUrl: Lb ("$$ absUrl"), url: function (a) {if (z (a)) retorna isso. $$ url ; var b = ph.exec (a); (b [1] || "" === a) && this.path (decodeURIComponent (b [1])); (b [2] || b [1] | | "" === a) && this.search (b [3] || ""); this.hash (b [5] || ""); retorne isso}, protocolo: Lb ("$$ protocol") , host: Lb ("$$ host"), porta: Lb ("$$ port"), caminho: Dd ("$$ path", função (a) {a = null! ==
a? a.toString (): ""; return "/" === a.charAt (0)? a: "/" + a}), pesquisa: function (a, b) {switch (argumentos. comprimento) {caso 0: retorne isso. $$ pesquisa; caso 1: se (A (a) || W (a)) a = a.toString (), isto. $$ pesquisa = gc (a); caso contrário, se (D (a)) a = Ia (a, {}), r (a, função (b, c) {null == b && delete a [c]}), isto. $$ search = a; else throw jb ("isrcharg "); break; default: z (b) || null === b? exclua isso. $$ search [a]: this. $$ search [a] = b} isso. $$ compose (); retorne isso }, hash: Dd ("$$ hash", função (a) {return null! == a? a.toString (): ""}), substitua: function () {this. $$ replace =! 0; retorne isso}};
r ([Cd, zc, yc], função (a) {a.prototype = Object.create (qh); a.prototype.state = function (b) {if (! argument.length) retorna isso. $$ state ; if (a! == yc ||! this. $$ html5) throw jb ("nostate"); this. $$ state = z (b)? null: b; this. $$ urlUpdatedByLocation =! 0; return this}}); var Ya = F ("$ parse"), Rg = {}. constructor.prototype.valueOf, Ub = T (); r ("+ - * /% ===! == ==! = <> <=> = && ||! = | ".split (" "), função (a) {Ub [a] =! 0}); var rh = {n:" \ n ", f:" \ f ", r:" \ r ", t:" \ t ", v:" \ v "," '":"' ", '"': '"'}, Nb = função (a) {isto .options = a}; Nb.prototype = {construtor: Nb,
lex: function (a) {this.text = a; this.index = 0; for (this.tokens = []; this.index <this.text.length;) if (a = this.text.charAt (this .index), '"' === a ||" '"=== a) this.readString (a); caso contrário, se (this.isNumber (a) ||". "=== a && this.isNumber (this .peek ())) this.readNumber (); else if (this.isIdentifierStart (this.peekMultichar ())) this.readIdent (); else if (this.is (a, "() {} []., ;:? ")) this.tokens.push ({index: this.index, text: a}), this.index ++; else if (this.isWhitespace (a)) this.index ++; else {var b = a + this.peek (), d = b + this.peek (2), c = Ub [b], e = Ub [d]; Ub [a] ||
c || e? (a = e? d: c? b: a, this.tokens.push ({index: this.index, text: a, operator:! 0}), this.index + = a.length) : this.throwError ("próximo caractere inesperado", this.index, this.index + 1)} retorna this.tokens}, is: function (a, b) {return-1! == b.indexOf (a)} , peek: function (a) {a = a || 1; retorna this.index + a <this.text.length? this.text.charAt (this.index + a) :! 1}, isNumber: function (a ) {return "0" <= a && "9"> = a && "string" === tipo de a}, isWhitespace: function (a) {return "" === a || "\ r" === a | | "\ t" === a || "\ n" === a || "\ v" === a || "\ u00a0" === a}, isIdentifierStart: function (a) {retorne isso .options.isIdentifierStart?
this.options.isIdentifierStart (a, this.codePointAt (a)): this.isValidIdentifierStart (a)}, isValidIdentifierStart: function (a) {return "a" <= a && "z"> = a || "A" < = a && "Z"> = a || "_" === a || "$" === a}, isIdentifierContinue: function (a) {retorne this.options.isIdentifierContinue? this.options.isIdentifierContinue (a, this.codePointAt (a)): this.isValidIdentifierContinue (a)}, isValidIdentifierContinue: function (a, b) {retorna this.isValidIdentifierStart (a, b) || this.isNumber (a)}, codePointAt: function (a) {return 1 === a.length? a.charCodeAt (0):
(a.charCodeAt (0) << 10) + a.charCodeAt (1) -56613888}, peekMultichar: function () {var a = this.text.charAt (this.index), b = this.peek (); Se (! b) retornar a; var d = a.charCodeAt (0), c = b.charCodeAt (0); retornar 55296 <= d && 56319> = d && 56320 <= c && 57343> = c? a + b: a}, isExpOperator : function (a) {return "-" === a || "+" === a || this.isNumber (a)}, throwError: function (a, b, d) {d = d || this .index; b = w (b)? "s" + b + "-" + this.index + "[" + this.text.substring (b, d) + "]": "" + d; lança Ya (" lexerr ", a, b, this.text);}, readNumber: function () {for (var a =" ", b = this.index; this.index <
Este texto.length;) {var d = K (this.text.charAt (this.index)); if ("." === d || this.isNumber (d)) a + = d; else {var c = this.peek (); if ("e" === d && this.isExpOperator (c)) a + = d; caso contrário, if (this.isExpOperator (d) && c && this.isNumber (c) && "e" === .charAt (a.length-1)) a + = d; caso contrário, se (! this.isExpOperator (d) || c && this.isNumber (c) || ​​"e"! == a.charAt (a.length-1) ); break; else this.throwError ("Expoente inválido")} this.index ++} this.tokens.push ({index: b, text: a, constant:! 0, value: Number (a)})}, readIdent: function () {var a = this.index; for (this.index + = this.peekMultichar (). length; this.index <
Este texto.length;) {var b = this.peekMultichar (); if (! this.isIdentifierContinue (b)) break; this.index + = b.length} this.tokens.push ({index: a, text: this.text.slice (a, this.index), identificador:! 0})}, readString: function (a) {var b = this.index; this.index ++; for (var d = "", c = a , e =! 1; this.index <this.text.length;) {var f = this.text.charAt (this.index), c = c + f; if (e) "u" === f? (e = this.text.substring (this.index + 1, this.index + 5), e.match (/ [\ da-f] {4} / i) || this.throwError ("escape unicode inválido [ \\ u "+ e +"] "), this.index + = 4, d + = String.fromCharCode (parseInt (e,
16))): d + = rh [f] || f, e =! 1; else if ("\\" === f) e =! 0; else {if (f === a) {this. index ++; this.tokens.push ({index: b, texto: c, constante:! 0, valor: d}); retorno} d + = f} this.index ++} this.throwError ("Citação não terminada", b)} }; var q = function (a, b) {this.lexer = a; this.options = b}; q.Program = "Program"; q.ExpressionStatement = "ExpressionStatement"; q.AssignmentExpression = "AssignmentExpression"; q .ConditionalExpression = "ConditionalExpression"; q.LogicalExpression = "LogicalExpression"; q.BinaryExpression = "BinaryExpression"; q.UnaryExpression = "UnaryExpression";
q.CallExpression = "CallExpression"; q.MemberExpression = "MemberExpression"; q.Identifier = "Identificador"; q.Literal = "Literal"; q.ArrayExpression = "ArrayExpression"; q.Property = "Property"; q. ObjectExpression = "ObjectExpression"; q.ThisExpression = "ThisExpression"; q.LocalsExpression = "LocalsExpression"; q.NGValueParameter = "NGValueParameter"; q.prototype = {ast: function (a) {this.text = a; this. tokens = this.lexer.lex (a); a = this.program (); 0! == this.tokens.length && this.throwError ("é um token inesperado", this.tokens [0]); retorne a},
programa: function () {para (var a = [] ;;) if (0 <this.tokens.length &&! this.peek ("}", ")", ";", "]") && a.push ( this.expressionStatement ()) ,! this.expect (";")) return {type: q.Program, body: a}}, expressionStatement: function () {return {type: q.ExpressionStatement, expressão: this.filterChain ()}}, filterChain: function () {for (var a = this.expression (); this.expect ("|");) a = this.filter (a); retorne a}, expression: function () {return this.assignment ()}, assignment: function () {var a = this.ternary (); if (this.expect ("=")) {if (! Hd (a)) lança Ya ("lval" );
a = {type: q.AssignmentExpression, left: a, right: this.assignment (), operator: "="}} retorne a}, ternário: function () {var a = this.logicalOR (), b, d ; return this.expect ("?") && (b = this.expression (), this.consume (":"))? (d = this.expression (), {type: q.ConditionalExpression, teste: a, alternativo: b, consequente: d}): a}, lógicoOR: function () {for (var a = this.logicalAND (); this.expect ("||");) a = {type: q.LogicalExpression, operador: "||", esquerda: a, direita: this.logicalAND ()}; retorna a}, lógicaAND: function () {for (var a = this.equality (); this.expect ("&&"); ) a =
{type: q.LogicalExpression, operator: "&&", left: a, right: this.equality ()}; retorne a}, igualdade: function () {para (var a = this.relacional (), b; b = this.expect ("==", "! =", "===", "! ==");) a = {type: q.BinaryExpression, operador: b.text, left: a, right: this.relational ()}; retorna a}, relational: function () {for (var a = this.additive (), b; b = this.expect ("<", ">", "<=", " > = ");) a = {tipo: q.BinaryExpression, operador: b.text, esquerda: a, direita: this.additive ()}; retorna a}, aditivo: function () {for (var a = this .multiplicative (), b; b = this.expect ("+", "-");) a = {type: q.BinaryExpression,
operador: b.text, esquerda: a, direita: this.multiplicative ()}; retorna a}, multiplicativa: function () {for (var a = this.unary (), b; b = this.expect ("* "," / ","% ");) a = {tipo: q.BinaryExpression, operador: b.text, left: a, right: this.unary ()}; retorne a}, unary: function () { var a; return (a = this.expect ("+", "-", "!"))? {type: q.UnaryExpression, operador: a.text, prefixo:! 0, argumento: this.unary () }: this.primary ()}, primary: function () {var a; this.expect ("(")? (a = this.filterChain (), this.consume (")")): this.expect ( "[")? a = this.arrayDeclaration (): this.expect ("{")?
a = this.object (): this.selfReferential.hasOwnProperty (this.peek (). text)? a = Ia (this.selfReferential [this.selfReferential [this.selfume (). text]): this.options.literals.hasOwnProperty (this .peek (). texto)? a = {tipo: q.Literal, valor: this.options.literals [this.consume (). text]}: this.peek (). identifier? a = this.identifier () : this.peek (). constant? a = this.constant (): this.throwError ("não é uma expressão primária", this.peek ()); for (var b; b = this.expect ("(", "[", ".");) "(" === b.text? (a = {type: q.CallExpression, chamado: a, argumentos: this.parseArguments ()}, this.consume (")" )):
"[" === b.text? (a = {type: q.MemberExpression, objeto: a, propriedade: this.expression (), calculada:! 0}, this.consume ("]")): ". "=== b.text? a = {tipo: q.MemberExpression, objeto: a, propriedade: this.identifier (), calculada:! 1}: this.throwError (" IMPOSSIBLE "); retorne a}, filtro: function (a) {a = [a]; for (var b = {type: q.CallExpression, call: this.identifier (), argumentos: a, filter:! 0}; this.expect (":"); ) a.push (this.expression ()); return b}, parseArguments: function () {var a = []; if (")"! == this.peekToken (). text) {faça ​​a.push ( this.filterChain ()); while (this.expect (","))
} retorna a}, identificador: function () {var a = this.consume (); a.identifier || this.throwError ("não é um identificador válido", a); return {type: q.Identifier, name: a.text}}, constante: function () {return {tipo: q.Literal, valor: this.consume (). value}}, arrayDeclaration: function () {var a = []; if ("]"! == this.peekToken (). text) {do {if (this.peek ("]")) break; a.push (this.expression ())} while (this.expect (","))} this .consume ("]"); return {type: q.ArrayExpression, elementos: a}}, objeto: function () {var a = [], b; if ("}"! == this.peekToken (). texto) {do {if (this.peek ("}")) quebra;
b = {type: q.Property, type: "init"}; this.peek (). constant? (b.key = this.constant (), b.computado =! 1, this.consume (":") , b.valor = esta.expressão ()): este.peek (). identificador? (b.key = este.identificador (), b.computado =! 1, este.peek (":")? (este. consumir (":"), b.valor = esta.expressão ()): b.valor = b.key): this.peek ("[")? (this.consume ("["), b.key = this.expression (), this.consume ("]"), b.computado =! 0, this.consume (":"), b.value = this.expression ()): this.throwError ("chave inválida" , this.peek ()); a.push (b)} while (this.expect (","))} this.consume ("}");
return {type: q.ObjectExpression, properties: a}}, throwError: function (a, b) {throw Ya ("sintaxe", b.text, a, b.index + 1, this.text, this.text. substring (b.index));}, consume: function (a) {if (0 === this.tokens.length) lança Ya ("ueoe", this.text); var b = this.expect (a) ; b || this.throwError ("é inesperado, esperando [" + a + "]", this.peek ()); retorne b}, peekToken: function () {if (0 === this.tokens.length) jogar Ya ("ueoe", this.text); retornar this.tokens [0]}, peek: function (a, b, d, c) {retornar this.peekAhead (0, a, b, d, c)} , peekAhead: function (a, b, d, c,
e) {if (this.tokens.length> a) {a = this.tokens [a]; var f = a.text; if (f === b || f === d || f === c || f === e ||! (b || d || c || e)) retorna a} return! 1}, espera: function (a, b, d, c) {return (a = this .peek (a, b, d, c))? (this.tokens.shift (), a) :! 1}, selfReferential: {"this": {type: q.ThisExpression}, $ locals: {type: q.LocalsExpression}}}; var Fd = 2; Jd.prototype = {compile: function (a) {var b = this; this.state = {nextId: 0, filtros: {}, fn: {vars: [] , corpo: [], próprio: {}}, atribuir: {vars: [], corpo: [], próprio: {}}, entradas: []}; Z (a, b. $ filter); var d = "", c; this.stage = "assign"; if (c = Id (a)) this.state.computing =
"atribuir", d = this.nextId (), this.recurse (c, d), this.return_ (d), d = "fn.assign =" + this.generateFunction ("assign", "s, v, l "); c = Gd (a.body); b.stage =" inputs "; r (c, função (a, c) {var d =" fn "+ c; b.state [d] = {vars : [], corpo: [], próprio: {}}; b.state.computing = d; var k = b.nextId (); b.recurse (a, k); b.return_ (k); b. state.inputs.push ({name: d, isPure: a.isPure}); a.watchId = c}); this.state.computing = "fn"; this.stage = "main"; this.recurse (a ); a = '"' + this.USE +" "+ this.STRICT + '"; \ n' + this.filterPrefix () + "var fn =" + this.generateFunction ("fn", "s, l, a , i ") +
d + this.watchFns () + "return fn;"; a = (new Function ("$ filter", "getStringValue", "ifDefined", "plus", a)) (this. $ filter, Og, Pg, Ed); this.state = this.stage = void 0; return a}, USE: "use", STRICT: "strict", watchFns: function () {var a = [], b = this.state.inputs, d = this; r (b, function (b) {a.push ("var" + b.name + "=" + d.generateFunction (b.name, "s")); b.isPure && a.push (b. nome, ". isPure =" + JSON.stringify (b.isPure) + ";")}); b.length && a.push ("fn.inputs = [" + b.map (function (a) {return a. nome}). join (",") + "];"); retorne a.join ("")}, generateFunction: function (a,
b) {return "function (" + b + ") {" + this.varsPrefix (a) + this.body (a) + "};"}, filterPrefix: function () {var a = [], b = this ; r (this.state.filters, function (d, c) {a.push (d + "= $ filter (" + b.escape (c) + ")")}); retornar a.length? "var" + a.join (",") + ";": ""}, varsPrefix: function (a) {retorna this.state [a] .vars.length? "var" + this.state [a] .vars. junção (",") + ";": ""}, corpo: função (a) {retorna this.state [a] .body.join ("")}, recurso: função (a, b, d, c , e, f) {var g, k, h = isto, l, m, p; c = c || E; se (! f &&w (a.watchId)) b = b || this.nextId (), isto .if _ ("i", this.lazyAssign (b,
this.computedMember ("i", a.watchId)), this.lazyRecurse (a, b, d, c, e,! 0)); else switch (a.type) {case q.Programa: r (a. corpo, função (b, c) {h.recurse (b.expressão, vazio 0, vazio 0, função (a) {k = a}); c! == a.body.length-1? h.current ( ) .body.push (k, ";"): h.return_ (k)}); break; case q.Literal: m = this.escape (a.value); this.assign (b, m); c (b || m); break; case q.UnaryExpression: this.recurse (a.argument, void 0, void 0, function (a) {k = a}); m = a.operator + "(" + this. ifDefined (k, 0) + ")"; this.assign (b, m); c (m); break; case q.BinaryExpression: this.recurse (a.left,
void 0, void 0, function (a) {g = a}); this.recurse (a.right, void 0, void 0, function (a) {k = a}); m = "+" === a.operator? this.plus (g, k): "-" === a.operator? this.ifDefined (g, 0) + a.operator + this.ifDefined (k, 0): "(" + g + ")" + a.operator + "(" + k + ")"; this.assign (b, m); c (m); break; case q.Expressão lógica: b = b || this.nextId (); h. recurse (a.left, b); h.if _ ("&&" === a.operator? b: h.not (b), h.lazyRecurse (a.right, b)); c (b); break ; case q.ConditionalExpression: b = b || this.nextId (); h.recurse (a.test, b); h.if_ (b, h.lazyRecurse (a.alternate, b), h.lazyRecurse (a .conseqüente,
b)); c (b); break; case q.Identificador: b = b || this.nextId (); d && (d.context = "inputs" === h.stage? "s": this.assign (this.nextId (), this.getHasOwnProperty ("l", a.name) + "? l: s"), d.computado =! 1, d.name = a.name); h.if _ ("inputs "=== h.stage || h.not (h.getHasOwnProperty (" l ", a.name)), função () {h.if _ (" entradas "=== h.stage ||" s ", function () {e && 1! == e && h.if_ (h.isNull (h.nonComputedMember ("s", um.nome)), h.lazyAssign (h.nonComputedMember ("s", um.nome), "{} ")); h.assign (b, h.nonComputedMember (" s ", a.name))})}, b && h.lazyAssign (b, h.nonComputedMember (" l ",
(a.name))); c (b); break; case q.MemberExpression: g = d && (d.context = this.nextId ()) || this.nextId (); b = b || this.nextId ( ); h.recurse (a.object, g, void 0, function () {h.if_ (h.notNull (g), function () {a.computed? (k = h.nextId (), h.recurse (a.property, k), h.getStringValue (k), e && 1! == e && h.if_ (h.not (h.computedMember (g, k)), h.lazyAssign (h.computedMember (g, k), "{}")), m = h.computedMember (g, k), h.assign (b, m), d && (d.computado =! 0, d.name = k)) :( e && 1! == e && h .if_ (h.isNull (h.nonComputedMember (g, a.property.name)), h.lazyAssign (h.nonComputedMember (g,
a.property.name), "{}")), m = h.nonComputedMember (g, a.property.name), h.assign (b, m), d && (d.computed =! 1, d.name = a.property.name))}, function () {h.assign (b, "indefinido")}); c (b)}, !! e); break; case q.CallExpression: b = b || Este.nextId (); a.filter? (k = h.filter (a.callee.name), l = [], r (a.arguments, function (a) {var b = h.nextId (); h .recurse (a, b); l.push (b)}), m = k + "(" + l.join (",") + ")", h.assign (b, m), c (b) ) :( k = h.nextId (), g = {}, l = [], h.recurse (a.callee, k, g, function () {h.if_ (h.notNull (k), function ( ) {r (argumentos, função (b) {h.recurse (b, a.constant?
void 0: h.nextId (), void 0, function (a) {l.push (a)})}); m = g.name? h.member (g.context, g.name, g.computed) + "(" + l.join (",") + ")": k + "(" + l.join (",") + ")"; h.assign (b, m)}, função () { h.assign (b, "indefinido")}); c (b)})); break; case q.AssignmentExpression: k = this.nextId (); g = {}; this.recurse (a.left, void 0, g, function () {h.if_ (h.notNull (g.context), function () {h.recurse (a.right, k); m = h.member (g.context, g.name, g.computado) + a.operator + k; h.assign (b, m); c (b || m)})}, 1); break; case q.ArrayExpression: l = []; r (a. elementos, função (b) {h.recurse (b,
a.constant? void 0: h.nextId (), void 0, function (a) {l.push (a)})}); m = "[" + l.join (",") + "]" ; this.assign (b, m); c (b || m); break; case q.ObjectExpression: l = []; p =! 1; r (a.properties, function (a) {a.computed && ( p =! 0)}); p? (b = b || this.nextId (), this.assign (b, "{}"), r (a.properties, função (a) {a.computada? ( g = h.nextId (), h.recurse (a.key, g)): g = a.key.type === qIdentificador? a.key.name: "" + a.key.value; k = h.nextId (); h.recurse (a.value, k); h.assign (h.member (b, g, a.computed), k)})) :( r (a.properties, function ( b) {h.recurse (b.value, a.constant? void 0:
h.nextId (), void 0, function (a) {l.push (h.escape (b.key.type === qIdentificador? b.key.name: "" + b.key.value) ":" + a)})}), m = "{" + l.join (",") + "}", este.atribuir (b, m)); c (b || m); quebrar; case q.Esta expressão: this.assign (b, "s"); c (b || "s"); break; case q.LocalsExpression: this.assign (b, "l"); c (b || " l "); break; case q.NGValueParameter: this.assign (b," v "), c (b ||" v ")}}, getHasOwnProperty: function (a, b) {var d = a +". " + b, c = this.current (). own; c.hasOwnProperty (d) || (c [d] = this.nextId (! 1, a + "&& (" + this.escape (b) + "in" + a + ")")); retorne c [d]}, atribua: function (a,
b) {if (a) retorna this.current (). body.push (a, "=", b, ";"), a}, filter: function (a) {this.state.filters.hasOwnProperty (a ) || (this.state.filters [a] = this.nextId (! 0)); retorne this.state.filters [a]}, ifDefined: function (a, b) {return "ifDefined (" + a + " , "+ this.escape (b) +") "}, plus: function (a, b) {return" mais ("+ a +", "+ b +") "}, return_: function (a) {this. atual (). body.push ("return", a, ";")}, if_: function (a, b, d) {if (! 0 === a) b ();else {var c = this.current (). body; c.push ("if (", a, ") {"); b (); c.push ("}"); d && (c.push (" else {"), d (), c.push ("} "))}},
not: function (a) {return "! (" + a + ")"}, isNull: function (a) {return a + "== null"}, notNull: function (a) {return a + "! = null"} , nonComputedMember: function (a, b) {var d = / [^ $ _ a-zA-Z0-9] / g; return / ^ [$ _ a-zA-Z] [$ _ a-zA-Z0-9] * $ /. test (b)? a + "." + b: a + '["' + b.replace (d, this.stringEscapeFn) + '"]'}, computedMember: function (a, b) {return a + " ["+ b +"] "}, membro: function (a, b, d) {return d? this.computedMember (a, b): this.nonComputedMember (a, b)}, getStringValue: function (a) {this .assign (a, "getStringValue (" + a + ")")}, lazyRecurse: function (a, b, d, c, e, f) {var g =
() () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () , b)}}, stringEscapeRegex: / [^ a-zA-Z0-9] / g, stringEscapeFn: function (a) {return "\\ u" + ("0000" + a.charCodeAt (0) .toString ( 16)). Slice (-4)}, escape: function (a) {if (A (a)) retorna "'" + a.replace (this.stringEscapeRegex, this.stringEscapeFn) + "'"; if (W (a)) retorna a.toString (); if (! 0 === a) retorna "true"; if (! 1 === a) retorna "false"; if (null === a) retorna "null "; if (" indefinido "=== tipo de a) retorna" indefinido "; lança Ya (" esc ");}, nextId: function (a,
b) {var d = "v" + this.state.nextId ++; a || this.current (). vars.push (d + (b? "=" + b: "")); retorne d}, atual: function () {return this.state [this.state.computing]}}; Kd.prototype = {compile: function (a) {var b = this; Z (a, b. $ filter); var d, c; if (d = Id (a)) c = this.recurse (d); d = Gd (a.body); var e; d && (e = [], r (d, função (a, c) {var d = b.recurse (a); d.isPure = a.isPure; a.input = d; e.push (d); a.watchId = c})); var f = []; r (a.body, função (a) {f.push (b.recurse (a.expression))}); a = 0 === a.body.length? E: 1 === a.body.length? f [0]: função (a, b) {var c; r (f, função (d) {c =
(a, b)}); return c}; c && (a.assign = function (a, b, d) {return c (a, d, b)}); e && (a.inputs = e); return a}, recurse: function (a, b, d) {var c, e, f = this, g; if (a.input) retorna this.inputs (a.input, a.watchId); switch (a.type ) {case q.Literal: retorna this.value (a.value, b); case q.UnaryExpression: retorna e = this.recurse (a.argument), this ["unary" + a.operator] (e, b ); case q.BinaryExpression: return c = this.recurse (a.left), e = this.recurse (a.right), this ["binary" + a.operator] (c, e, b); case q .LogicalExpression: return c = this.recurse (a.left), e = this.recurse (a.right),
this ["binário" + a.operator] (c, e, b); case q.ConditionalExpression: retorna este ["ternário?:"] (this.recurse (a.test), this.recurse (a.alternate) , this.recurse (a.consequent), b); case q.Identifier: return f.identifier (a.name, b, d); case q.MemberExpression: return c = this.recurse (a.object,! 1 , !! d), a.computado || (e = a.property.name), a.computed && (e = this.recurse (a.property)), a.computed? this.computedMember (c, e, b , d): this.nonComputedMember (c, e, b, d); case q.CallExpression: return g = [], r (argumentos, função (a) {g.push (f.recurse (a)) }),
a.filter && (e = this. $ filter (a.callee.name)), a.filter || (e = this.recurse (a.callee,! 0)), função a.filter? (a, c, d, f) {para (var p = [], n = 0; n <comprimento de g; ++ n) p.push (g [n] (a, c, d, f)); a = e. aplicar (void 0, p, f); retornar b? {contexto: void 0, nome: void 0, valor: a}: a}: function (a, c, d, f) {var p = e (a, c, d, f), n; if (null! = p.value) {n = []; for (var s = 0; s <g.length; ++ s) n.push (g [s] ( a, c, d, f)); n = p.valor.apply (p.context, n)} retornar b? {valor: n}: n}; caso q.AssignmentExpression: retornar c = this.recurse (a .left,! 0,1), e = this.recurse (a.right), função (a, d, f, g) {var p =
c (a, d, f, g); a = e (a, d, f, g); p.context [p.name] = a; retorne b? {valor: a}: a}; case q. ArrayExpression: return g = [], r (elementos, função (a) {g.push (f.recurse (a))}), função (a, c, d, e) {for (var f = [ ], n = 0; n <comprimento g; ++ n) f.push (g [n] (a, c, d, e)); return b? {value: f}: f}; case q. ObjectExpression: return g = [], r (a.properties, function (a) {a.computed? G.push ({key: f.recurse (a.key), calculado:! 0, valor: f.recurse ( a.value)}): g.push ({chave: a.key.type === qIdentificador? a.key.name: "" + a.key.value, calculado:! 1, valor: f. recurse (a.value)})}), function (a,
c, d, e) {para (var f = {}, n = 0; n <g.length; ++ n) g [n] .computado? f [g [n] .key (a, c, d , e)] = g [n] .valor (a, c, d, e): f [g [n] .key] = g [n] .valor (a, c, d, e); return b? {value: f}: f}; case q.Expressão: função de retorno (a) {return b? {value: a}: a}; case q.LocalsExpression: função de retorno (a, c) {return b? {value : c}: c}; case q.NGValueParameter: função de retorno (a, c, d) {return b? {value: d}: d}}}, "unário +": função (a, b) {função de retorno ( d, c, e, f) {d = a (d, c, e, f); d = w (d)? + d: 0; retornar b? {valor: d}: d}}, "unary- ": função (a, b) {função de retorno (d, c, e, f) {d = a (d, c,
e, f); d = w (d)? - d: -0; retorno b? {valor: d}: d}}, "unário!": função (a, b) {função de retorno (d, c, e, f) {d =! a (d, c, e, f); retorna b? {valor: d}: d}}, "binário +": function (a, b, d) {retorna função (c, e, f, g) {var k = a (c, e, f, g); c = b (c, e, f, g); k = Ed (k, c); retorno d? {valor: k }: k}}, "binário -": function (a, b, d) {função de retorno (c, e, f, g) {var k = a (c, e, f, g); c = b ( c, e, f, g); k = (w (k)? k: 0) - (w (c)? c: 0); retorno d? {valor: k}: k}}, "binário *" : função (a, b, d) {função de retorno (c, e, f, g) {c = a (c, e, f, g) * b (c, e, f, g); return d? { valor: c}: c}}, "binário /": function (a, b, d) {função de retorno (c,
e, f, g) {c = a (c, e, f, g) / b (c, e, f, g); retorno d? {valor: c}: c}}, "% binário": function (a, b, d) {função de retorno (c, e, f, g) {c = a (c, e, f, g)% b (c, e, f, g); return d? {value: c}: c}}, "binário ===": function (a, b, d) {função de retorno (c, e, f, g) {c = a (c, e, f, g) === b (c, e, f, g); return d? {value: c}: c}}, "binário! ==": function (a, b, d) {função de retorno (c, e, f, g ) {c = a (c, e, f, g)! == b (c, e, f, g); retorna d? {valor: c}: c}}, "binário ==": function (a , b, d) {função de retorno (c, e, f, g) {c = a (c, e, f, g) == b (c, e, f, g); return d? {value: c }: c}}, "binário! =": function (a, b, d) {função de retorno (c,
e, f, g) {c = a (c, e, f, g)! = b (c, e, f, g); retorna d? {valor: c}: c}}, "binário <": função (a, b, d) {função de retorno (c, e, f, g) {c = a (c, e, f, g) <b (c, e, f, g); return d? {value : c}: c}}, "binário>": function (a, b, d) {função de retorno (c, e, f, g) {c = a (c, e, f, g)> b (c , e, f, g); return d? {valor: c}: c}}, "binário <=": function (a, b, d) {função de retorno (c, e, f, g) {c = a (c, e, f, g) <= b (c, e, f, g); return d? {valor: c}: c}}, "binário> =": função (a, b, d) {função de retorno (c, e, f, g) {c = a (c, e, f, g)> = b (c, e, f, g); return d? {value: c}: c}} , "binário &&": função (a, b, d) {função de retorno (c, e, f, g) {c =
a (c, e, f, g) && b (c, e, f, g); return d? {value: c}: c}}, "binário ||": function (a, b, d) {return função (c, e, f, g) {c = a (c, e, f, g) || b (c, e, f, g); retornar d? {value: c}: c}}, " ternário?: ": function (a, b, d, c) {função de retorno (e, f, g, k) {e = a (e, f, g, k)? b (e, f, g, k ): d (e, f, g, k); return c? {valor: e}: e}}, value: function (a, b) {função de retorno () {return b? {contexto: void 0, name : void 0, valor: a}: a}}, identificador: function (a, b, d) {função de retorno (c, e, f, g) {c = e && a em e? e: c; d && 1! == d && c && null == c [a] && (c [a] = {}); e = c? c [a]: nulo 0; retorne b? {contexto: c, nome: a, valor: e}:
e}}, computedMember: function (a, b, d, c) {função de retorno (e, f, g, k) {var h = a (e, f, g, k), l, m; null! = h && (l = b (e, f, g, k), l + = "", c && 1! == c && h &&! h [l] && (h [l] = {}), m = h [l]); return d? {contexto: h, nome: l, valor: m}: m}}, nonComputedMember: function (a, b, d, c) {função de retorno (e, f, g, k) {e = a (e , f, g, k); c && 1! == c && e && null == e [b] && (e [b] = {}); f = nulo! = e? e [b]: vazio 0; retorno d? {contexto : e, nome: b, valor: f}: f}}, entradas: function (a, b) {return function (d, c, e, f) {return f? f [b]: a (d, c , e)}}}; Mb.prototype = {construtor: Mb, parse: function (a) {a = this.getAst (a); var b =
this.astCompiler.compile (a.ast), d = a.ast; b.literal = 0 === d.body.length || 1 === d.body.length && (d.body [0] .expression .type === q.Literal || d.body [0] .expression.type === q.ArrayExpression || d.body [0] .expression.type === q.ObjectExpression); b.constant = a.ast.constant; b.oneTime = a.oneTime; return b}, getAst: function (a) {var b =! 1; a = a.trim (); ":" === a.charAt (0 ) && ":" === a.charAt (1) && (b =! 0, a = a.substring (2)); return {ast: this.ast.ast (a), oneTime: b}}} ; var Ea = F ("$ sce"), V = {HTML: "html", CSS: "css", MEDIA_URL: "mediaUrl", URL: "url", RESOURCE_URL: "resourceUrl",
JS: "js"}, Cc = / _ ([az]) / g, Ug = F ("$ templateRequest"), Vg = F ("$ timeout"), aa = C.document.createElement ("a" ), Od = ga (C.location.href), Na; aa.href = "http: // [:: 1]"; var Wg = "[:: 1]" === aa.hostname; Pd. $ injetar = ["$ documento"]; dd. $ injetar = ["$ fornecer"]; var Wd = 22, Vd = ".", Ec = "0"; Qd. $ injetar = ["$ localidade"] ; Sd. $ Inject = ["$ locale"]; var gh = {aaaa: ea ("FullYear", 4,0,! 1,! 0), yy: ea ("FullYear", 2,0,! 0 ,! 0), y: ea ("FullYear", 1,0,! 1,! 0), MMMM: kb ("Mês"), MMM: kb ("Mês",! 0), MM: ea (" Month ", 2,1), M: ea (" Month ", 1,1), LLLL: kb (" Month ",! 1,! 0), dd: ea (" Date ", 2),
d: ea ("Data", 1), HH: ea ("Horas", 2), H: ea ("Horas", 1), hh: ea ("Horas", 2, -12), h: ea ("Horas", 1, -12), mm: ea ("Minutos", 2), m: ea ("Minutos", 1), ss: ea ("Segundos", 2), s: ea ("Segundos ", 1), sss: ea (" Milissegundos ", 3), EEEE: kb (" Dia "), EEE: kb (" Dia ",! 0), a: function (a, b) {return 12> a .getHours ()? b.AMPMS [0]: b.AMPMS [1]}, Z: função (a, b, d) {a = -1 * d; retorna a = (0 <= a? "+" : "") + (Ob (Math [0 <a? "Floor": "ceil"] (a / 60), 2) + Ob (Math.abs (a% 60), 2))}, ww: Yd (2), w: Yd (1), G: Fc, GG: Fc, GGG: Fc, GGGG: função (a, b) {return 0> = a.getFullYear ()? B.ERANAMES [0]: b .ERANAMES [1]}},
fh = / ((?: [^ yMLdHhmsaZEwG '] +) | (?:' (?: [^ '] |' ') *') | (?: E + | y ​​+ | M + | L + | d + | H + | h + | m + | s + | a | Z | G + | w +)) ([\ s \ S] *) /, eh = / ^ -? \ d + $ /; Rd. $ inject = ["$ locale"]; var $ g = ia (K), ah = ia (ub); Td. $ inject = ["$ parse"]; var Me = ia ({restringir: "E", compilar: função (a, b) {if (! b.href &&! b.xlinkHref) função de retorno (a, b) {if ("a" === b [0] .nodeName.toLowerCase ()) {var e = "[objeto SVGAnimatedString]" === la. chamada (b.prop ("href"))? "xlink: href": "href"; b.on ("clique", função (a) {b.attr (e) || a.preventDefault ()}) }}}}), vb = {}; r (Gb, função (a, b) {função d (a, d, e) {a. $ watch (e [c],
função (a) {e. $ set (b, !! a)})} if ("múltiplo"! == a) {var c = wa ("ng -" + b), e = d; "marcado" === a && (e = função (a, b, e) {e.ngModel! == e [c] && d (a, b, e)}); vb [c] = função () {retorno {restringir: "A", prioridade: 100, link: e}}}}); r (td, função (a, b) {vb [b] = função () {retorno {prioridade: 100, link: função (a, c , e) {if ("ngPattern" === b && "/" === e.ngPattern.charAt (0) && (c = e.ngPattern.match (ie))) {e. $ set ("ngPattern" , new RegExp (c [1], c [2])); return} a. $ watch (e [b], função (a) {e. $ set (b, a)})}}}}); r (["src", "srcset", "href"], função (a) {var b = wa ("ng -" + a); vb [b] =
["$ sce", função (d) {retorno {prioridade: 99, link: função (c, e, f) {var g = a, k = a; "href" === a && "[objeto SVGAnimatedString]" === la.call (e.prop ("href")) && (k = "xlinkHref", f. $ attr [k] = "xlink: href", g = nulo); f. $ set (b, d.getTrustedMediaUrl (f [b])); f. $ observe (b, função (b) {b? (f. $ set (k, b), Ca &&g && e.prop (g, f [k])): " href "=== a && f. $ set (k, null)})}}}]}); var lb = {$ addControl: E, $ getControls: ia ([]), $$ renameControl: function (a, b ) {a. $ name = b}, $ removeControl: E, $ setValidity: E, $ setDirty: E, $ setPristine: E, $ setSubmitted: E, $$ setSubmitted: E}; Pb. $ inject =
["$ element", "$ attrs", "$ scope", "$ animate", "$ interpolate"]; Pb.prototype = {$ rollbackViewValue: function () {r (este. $$ controles, função (a ) {a. $ rollbackViewValue ()})}, $ commitViewValue: function () {r (isto. $$ controla, função (a) {a. $ commitViewValue ()})}, $ addControl: function (a) { Ja (a. $ Name, "input"); this. $$ controls.push (a); a. $ Name && (this [a. $ Name] = a); a. $$ parentForm = this}, $ getControls : function () {return ja (this. $$ controls)}, $$ renameControl: function (a, b) {var d = a. $ name; this [d] === a && delete this [d]; this [ b] = a; a. $ name = b}, $ removeControl: function (a) {a. $ name &&
this [a. $ name] === a && delete this [a. $ name]; r (this. $ pendente, função (b, d) {this. $ setValidity (d, null, a)}, this); r (this. $ error, function (b, d) {this. $ setValidity (d, null, a)}, this); r (this. $$ success, função (b, d) {this. $ setValidity (d , null, a)}, this); cb (this. $$ controla, a); a. $$ parentForm = lb}, $ setDirty: function () {this. $$ animate.removeClass (this. $$ elemento , Za); this. $$ animate.addClass (this. $$ element, Vb); this. $ Dirty =! 0; this. $ Pristine =! 1; this. $$ parentForm. $ SetDirty ()}, $ setPristine: function () {this. $$ animate.setClass (this. $$ elemento,
Za, Vb + "ng-submit"); this. $ Dirty =! 1; this. $ Pristine =! 0; this. $ Submit =! 1; r (isso. $$ controla, função (a) {a. $ setPristine ()})}, $ setUntouched: function () {r (este. $$ controles, função (a) {a. $ setUntouched ()})}, $ setSubmitted: function () {for (var a = this ; a. $$ parentForm && a. $$ parentForm! == lb;) a = a. $$ parentForm; a. $$ setSubmitted ()}, $$ setSubmitted: function () {this. $$ animate.addClass (this . $$ elemento, "ng-enviado"); este. $ submit =! 0; r (este. $$ controles, função (a) {a. $$ setSubmitted && a. $$ setSubmitted ()})}}; ae ({clazz: Pb, set: function (a,
b, d) {var c = a [b]; c? -1 === c.indexOf (d) && c.push (d): a [b] = [d]}, desabilitado: function (a, b , d) {var c = a [b]; c && (cb (c, d), 0 === c.length && delete a [b])}}); var ke = function (a) {return ["$ timeout "," $ parse ", função (b, d) {função c (a) {return" "=== a? d ('this [" "]'). assign: d (a) .assign || E } retornar {nome: "formulário", restringir: a? ​​"EAC": "E", exigir: ["formulário", "^^? formulário"], controlador: Pb, compilar: função (d, f) {d .addClass (Za) .addClass (mb); var g = f.name? "name": a && f.ngForm? "ngForm":! 1; return {pre: function (a, d, e, f) {var p = f [0]; if (! ("ação" em e)) {var n = função (b) {a. $ apply (function () {p. $ commitViewValue ();
$ setSubmitted ()}); b.preventDefault ()}; d [0] .addEventListener ("submit", n); d.on ("$ destroy", function () {b (function () {d [0] .removeEventListener ("submit", n)}, 0,! 1)})} (f [1] || p. $$ parentForm). $ AddControl (p); var s = g? C (p . $ name): E; g && (s (a, p), e. $ observe (g, função (b) {p. $ name! == b && (s (a, void 0), p. $$ parentForm . $$ renomearControle (p, b), s = c (p. $ name), s (a, p))})); d.on ("$ destroy", function () {p. $$ parentForm. $ removeControl (p); s (a, vazio 0); S (p, lb)})}}}}}]}, Ne = ke (), Ze = ke (! 0), hh = / ^ \ d {4,} - [01] \ d- [0-3] \ dT [0-2] \ d: [0-5] \ d: [0-5] \ d \. \ D + (?: [+ -] [0-2] \ d: [0-5] \ d | Z) $ /,
sh = / ^ [az] [az \ d. + -] *: \ / * (?: [^: @] + (? :: [^ @] +)? @)? (?: [^ \ s : /? #] + | \ [[af \ d:] +]) (? :: \ d +)? (?: \ / [^? #] *)? (?: \? [^ #] *) ? (?: #. *)? $ / i, th = / ^ (? =. {1,254} $) (? =. {1,64} @) [-! # $% & '* + / 0- 9 =? AZ ^ _`az {|} ~] + (\. [-! # $% & '* + / 0-9 =? AZ ^ _`az {|} ~] +) * @ [A- Za-z0-9] ([A-Za-z0-9 -] {0,61} [A-Za-z0-9])? (\. [A-Za-z0-9] ([A-Za -z0-9 -] {0,61} [A-Za-z0-9])?) * $ /, ih = / ^ \ s * (- | \ +)? (\ d + | (\ d * ( \. \ d *))) ([eE] [+ -]? \ d +)? \ s * $ /, le = / ^ (\ d {4,}) - (\ d {2}) - (\ d {2}) $ /, me = / ^ (\ d {4,}) - (\ d \ d) - (\ d \ d) T (\ d \ d): (\ d \ d) (? :: (\ d \ d) (\. \ d {1,3})?)? $ /, Mc = / ^ (\ d {4,}) - W (\ d \ d) $ /, ne = / ^ (\ d {4,}) - (\ d \ d) $ /,
oe = / ^ (\ d \ d): (\ d \ d) (? :: (\ d \ d) (\. \ d {1,3})?)? $ /, ce = T (); r (["data", "datetime-local", "mês", "hora", "semana"], função (a) {ce [a] =! 0}); var pe = {text: function (a , b, d, c, e, f) {Sa (a, b, d, c, e, f); Hc (c)}, data: nb ("data", le, Qb (le, ["aaaa "," MM "," dd "])," aaaa-MM-dd ")," datetime-local ": nb (" datetimelocal ", eu, Qb (eu," aaaa MM dd HH mm ss sss ".split ("")), "aaaa-MM-ddTHH: mm: ss.sss"), tempo: nb ("tempo", oe, Qb (oe, ["HH", "mm", "ss", "sss) "])," HH: mm: ss.sss "), semana: nb (" semana ", Mc, função (a, b) {if (ha (a)) retorna a; if (A (a)) { Mc.lastIndex = 0; var d = Mc.exec (a);
se (d) {var c = + d [1], e = + d [2], f = d = 0, g = 0, k = 0, h = Xd (c), e = 7 * (e- 1); b && (d = b.getHours (), f = b.getMinutes (), g = b.getSeconds (), k = b.getMilliseconds ()); retorna nova data (c, 0, h.getDate ( ) + e, d, f, g, k)}} retornar NaN}, "aaaa-Www"), mês: nb ("mês", ne, Qb (ne, ["aaaa", "MM"])), "aaaa-MM"), número: função (a, b, d, c, e, f, g, k) {Ic (a, b, d, c, "número"); de (c); Sa ( a, b, d, c, e, f); var h; if (w (d.min) || d.ngMin) {var l = d.min || k (d.ngMin) (a); h = na (l); c. $ validators.min = função (a, b) {return c. $ isEmpty (b) || z (h) || b> = h}; d. $ observe ("min" , função (a) {a! == l && (h = na (a),
l = a, c. $ validate ())})} if (w (d.max) || d.ngMax) {var m = d.max || k (d.ngMax) (a), p = na (m); c. $ validators.max = função (a, b) {return c. $ isEmpty (b) || z (p) || b <= p}; d. $ observe ("max", função (a) {a! == m && (p = na (a), m = a, c. $ validate ())})} if (w (d.step) || d.ngStep) {var n = d .step || k (d.ngStep) (a), s = na (n); c. $ validators.step = função (a, b) {return c. $ isEmpty (b) || z (s) | | ee (b, h || 0, s)}; d. $ observe ("etapa", função (a) {a! == n && (s = na (a), n = a, c. $ validate ( ))})}}, url: function (a, b, d, c, e, f) {Sa (a, b, d, c, e, f); Hc (c); c. $ validators.url = função (a, b) {var d =
a || b; return c. $ isEmpty (d) || sh.test (d)}}, email: function (a, b, d, c, e, f) {Sa (a, b, d, c , e, f); Hc (c); c. $ validators.email = função (a, b) {var d = a || b; retorno c. $ isEmpty (d) || o teste (d)} }, radio: function (a, b, d, c) {var e =! d.ngTrim || "false"! == U (d.ngTrim); z (nome do d.ng) && b.attr ("nome" , ++ pb); b.on ("alteração", função (a) {var g; b [0]. verificada && (g = valor.d, e && (g = U (g)), c. $ setViewValue ( g, a && a.type))}); c. $ render = function () {var a = d.value; e && (a = U (a)); b [0]. verificado = a === c. $ viewValue}; d. $ observe ("valor", c. $ render)}, range: function (a, b, d, c, e, f) {function g (a,
c) {b.attr (a, d [a]); var e = d [a]; d. $ observe (a, função (a) {a! == e && (e = a, c (a)) })} função k (a) {p = na (a); X (c. $ modelValue) || (m? (a = b.val (), p> a && (a = p, b.val (a )), c. $ setViewValue (a)): c. $ validate ())} função h (a) {n = na (a); X (c. $ modelValue) || (m? (a = b. O valor da variável é o valor do valor da variável, e o valor da variável é o valor da variável. = na (a); X (c. $ modelValue) || (m? c. $ viewValue! == b.val () && c. $ setViewValue (b.val ()): c. $ validate ())} Ic (a, b, d, c, "range"); de (c); Sa (a, b, d, c, e, f); var m = c. $$ hasNativeValidators && "range" === b [0]. Tipo, p = m?
0: vazio 0, n = m? 100: vazio 0, s = m? 1: vazio 0, r = b [0]. Validade; a = w (d.min); e = w (d.max); Se a resposta ajudou de alguma forma, por favor, clique em `` Resolvi meu problema '' localizado logo abaixo desta mensagem, caso a sua dúvida não tenha sido solucionada, por favor, poste novamente. val ())}: q; a && (p = na (d.min), c. $ validators.min = m? function () {return! 0}: function (a, b) {return c. $ isEmpty ( b) || z (p) || b> = p}, g ("min", k)); e && (n = na (d.max), c. $ validators.max = m? function () { return! 0}: function (a, b) {return c. $ isEmpty (b) || z (n) || b <= n}, g ("max", h)); f && (s = na ( d.step), c. $ validators.step = m? function () {return! r.stepMismatch}:
função (a, b) {return c. $ isEmpty (b) || z (s) || ee (b, p || 0, s)}, g ("etapa", l))}, caixa de seleção: function (a, b, d, c, e, f, g, k) {var h = fe (k, a, "ngTrueValue", d.ngTrueValue,! 0), l = fe (k, a, "ngFalseValue" , d.ngFalseValue,! 1); b.on ("alteração", função (a) {c. $ setViewValue (b [0]. verificado, a && a.type)}); c. $ render = function () { b [0] .checked = c. $ viewValue}; c. $ isEmpty = função (a) {return! 1 === a}; c. $ formatters.push (função (a) {return va (a, h $ parsers.push (função (a) {retornar a? h: l})}, oculto: E, botão: E, enviar: E, redefinir: E, arquivo: E}, Yc = [ "$ browser", "$ sniffer",
"$ filter", "$ parse", função (a, b, d, c) {return {restrita: "E", requer: ["? ngModel"], link: {pre: function (e, f, g , k) {k [0] && (pe [K (g.type)] || pe.text) (e, f, g, k [0], b, a, d, c)}}}}] , vf = function () {var a = {configurável:! 0, enumerável:! 1, get: function () {retorna this.getAttribute ("value") || ""}, defina: function (a) {this .setAttribute ("valor", a)}}; return {strict: "E", prioridade: 200, compile: function (b, d) {if ("hidden" === K (d.type)) return { pre: function (b, d, f, g) {b = d [0]; b.parentNode && b.parentNode.insertBefore (b, b.nextSibling); Object.defineProperty &&
Object.defineProperty (b, "valor", a)}}}}}, uh = / ^ (true | false | \ d +) $ /, sf = function () {function a (a, d, c) {var e = w (c)? c: 9 Ca? "": null; a.prop ("valor", e); d. $ set ("valor", c)} retornar {restringir: "A" , prioridade: 100, compile: function (b, d) {return uh.test (d.ngValue)? function (b, d, f) {b = b. $ eval (f.ngValue); a (d, f , b)}: function (b, d, f) {b. $ watch (f.ngValue, função (b) {a (d, f, b)})}}}}, Re = ["$ compile" , function (a) {return {restringir: "AC", compilar: function (b) {a. $$ addBindingClass (b); retornar a função (b, c, e) {a. $$ addBindingInfo (c, e. ngBind); c = c [0];
b. $ watch (e.ngBind, função (a) {c.textContent = ic (a)})}}}], Te = ["$ interpolate", "$ compile", função (a, b) { return {compile: function (d) {b. $$ addBindingClass (d); return function (c, d, f) {c = a (d.attr (f. $ attr.ngBindTemplate)); b. $$ addBindingInfo (d, c.expressions); d = d [0]; f. $ observe ("ngBindTemplate", função (a) {d.textContent = z (a)? "": a})}}}}], Se = ["$ sce", "$ parse", "$ compile", função (a, b, d) {return {restringir: "A", compilar: função (c, e) {var f = b (e .ngBindHtml), g = b (e.ngBindHtml, função (b) {retorna a.valueOf (b)}); d. $$ addBindingClass (c);
Você pode usar a função de retorno (b, c, e) {d. $$ addBindingInfo (c, e.ngBindHtml); b. $ watch (g, function () {var d = f (b); c.html (a.getTrustedHtml ( d) || "")})}}}]], rf = ia ({restring: "A", requer: "ngModel", link: function (a, b, d, c) {c. $ viewChangeListeners. push (function () {a. $ eval (d.ngChange)})}}), Ue = Kc ("",! 0), Nós = Kc ("Ímpar", 0), Ve = Kc ("Par" , 1), Xe = Ra ({compile: function (a, b) {b. $ Set ("ngCloak", void 0); a.removeClass ("ng-cloak")}}), Ye = [function ( ) {return {restrito: "A", escopo:! 0, controlador: "@", prioridade: 500}}], cd = {}, vh = {desfoque:! 0, foco:! 0}; r (" clique em dblclique mouse com mouse desativado mouseover mouseout mouse com mouse mouse com tecla mouseleave keydown keyup keypress enviar foco borrão copiar recortar colar ".split (" "),
função (a) {var b = wa ("ng -" + a); cd [b] = ["$ parse", "$ rootScope", "$ exceptionHandler", função (d, c, e) {return qd (d, c, e, b, a, vh [a])}]}); var af = ["$ animate", "$ compile", função (a, b) {return {multiElement:! 0, transclude : "elemento", prioridade: 600, terminal:! 0, restringir: "A", $$ tlb:! 0, link: função (d, c, e, f, g) {var k, h, l; d . $ watch (e.ngIf, função (d) {d? h || g (função (d, f) {h = f; d [comprimento d ++] = b. $$ createComment ("end ngIf", e .ngIf); k = {clone: ​​d}; a.enter (d, c.parent (), c)}) :( l && (l.remove (), l = null), h && (h. $ destroy ( ), h = nulo), k && (l = tb (k.clone),
a.leave (l) .done (function (a) {! 1! == a && (l = null)}), k = null))})}}}], bf = ["$ templateRequest", "$ anchorScroll "," $ animate ", função (a, b, d) {return {restrita:" ECA ", prioridade: 400, terminal:! 0, transclude:" element ", controller: ca.noop, compile: function ( c, e) {var f = e.ngIncluir || e.src, g = e.onload || "", k = e.autoscroll; função de retorno (c, e, m, p, n) {var r = 0, q, t, x, v = function () {t && (t.remove (), t = null); q && (q. $ Destroy (), q = null); x && (d.leave (x). (função (a) {! 1! == a && (t = nulo)}), t = x, x = nulo)}; c. $ watch (f, função (f) {var m = function (a) {! 1 ===
a ||! w (k) || k &&! c. $ eval (k) || b ()}, t = ++ r; f? (a (f,! 0). então (função (a) { Se (! c. $$ destruído && t === r) {var b = c. $ new (); p.template = a; a = n (b, função (a) {v (); d.enter (a , null, e) .done (m)}); q = b; x = a; q. $ emit ("$ includeContentLoaded", f); c. $ eval (g)}}, function () {c. $ $ destruído || t! == r || (v (), c. $ emit ("$ includeContentError", f))}), c. $ emit ("$ includeContentRequested", f)) :( v ( ), p.template = null)})}}}}], uf = ["$ compile", função (a) {return {strict: "ECA", prioridade: -400, requer: "ngInclude", link: função (b, d, c, e) {la.call (d [0]). match (/ SVG /)?
(d.empty (), a (ed (e.template, C.document) .childNodes) (b, função (a) {d.append (a)}, {futureParentElement: d})) :( d.html (e.template), a (d.contents ()) (b))}}}], cf = Ra ({prioridade: 450, compile: function () {return {pre: function (a, b, d) {a. $ eval (d.ngInit)}}}}), qf = function () {return {restrito: "A", prioridade: 100, requer: "ngModel", link: function (a, b, d, c) {var e = lista.ng || ",", f = "false"! == d.ngTrim, g = f? U (e): e; c. $ parsers.push (função (a) { if (! z (a)) {var b = []; a && r (a.split (g), função (a) {a && b.push (f? U (a): a)}); return b}}) ; c. $ formatters.push (função (a) {if (H (a)) retorna a.join (e)});
c. $ isEmpty = função (a) {return! a ||! a.length}}}}, mb = "ng-válido", $ d = "ng-inválido", Za = "ng-pristine", Vb = "ng-dirty", ob = F ("ngModel"); Rb. $ inject = "$ scope $ exceptionHandler $ atrai $ elemento $ parse $ animate $ timeout $ q $ interpola" .split (""); Rb. prototype = {$$ initGetterSetters: function () {if (this. $ options.getOption ("getterSetter")) {var a = this. $$ parse (this. $$ attr.ngModel + "()"), b = this. $$ parse (this. $$ attr.ngModel + "($$$ p)"); this. $$ ngModelGet = function (b) {var c = this. $$ parsedNgModel (b); B (c) && (c = a (b)); return c}; this. $$ ngModelSet =
função (a, c) {B (this. $$ parsedNgModel (a))? b (a, {$$$ p: c}): this. $$ parsedNgModelAssign (a, c)}} else if (! this . $$ parsedNgModel.assign) throw ob ("nonassign", this. $$ attr.ngModel, za (this. $$ elemento));}, $ render: E, $ isEmpty: function (a) {return z ( a) || "" === a || null === a || a! == a}, $$ updateEmptyClasses: função (a) {isto. $ isEmpty (a)? (isto. $$ animar. removeClass (este elemento. $$, "ng-not-empty"), este. $$ animate.addClass (este elemento. $$, "ng-empty")) :( this. $$ animate.removeClass (this. elemento $$, "ng-empty"), este. $$ animate.addClass (este elemento. $$,
"ng-not-empty"))}, $ setPristine: function () {this. $ dirty =! 1; this. $ pristine =! 0; this. $$ animate.removeClass (this. $$ element, Vb) ; this. $$ animate.addClass (this. $$ element, Za)}, $ setDirty: function () {this. $ dirty =! 0; this. $ pristine =! 1; this. $$ animate.removeClass ( Este elemento. $$, Za); este. $$ animate.addClass (este. $$ elemento, Vb); este. $$ parentForm. $ setDirty ()}, $ setUntouched: function () {this. $ touched = ! 1; this. $ Untouched =! 0; this. $$ animate.setClass (este elemento. $$, "ng-untouched", "ng-touched")}, $ setTouched: function () {this. $ Touched =
! 0; this. $ Untouched =! 1; this. $$ animate.setClass (este elemento. $$, "tocado em ng", "tocado em ng")}, $ rollbackViewValue: function () {this. $$ timeout.cancel (this. $$ pendingDebounce); this. $ viewValue = this. $$ lastCommittedViewValue; this. $ render ()}, $ validate: function () {if (! X (this. $ modelValue)) {var a = this. $$ lastCommittedViewValue, b = this. $$ rawModelValue, d = this. $ valid, c = this. $ modelValue, e = this. $ options.getOption ("allowInvalid"), f = this; this. $$ runValidators (b, a, função (a) {e || d === a || (f. $ modelValue = a? b: vazio 0, f. $ modelValue! ==
$ writeModelToScope ())})}}, $$ runValidators: function (a, b, d) {function c () {var c =! 0; r (h. $ validators, function (d, e) (var g = Boolean (d (a, b)); c = c & g; f (e, g)}); return c?! 0: (r (h. $ asyncValidators, função (a, b) {f ( b, nulo)}) ,! 1)} função e () {var c = [], d =! 0; r (h. $ asyncValidators, função (e, g) {var h = e (a, b) ; if (! h ||! B (h.then)) throw ob ("nopromise", h); f (g, void 0); c.push (h.then (function () {f (g ,! 0)}, function () {d =! 1; f (g,! 1)}))}); c.length? H. $$ q.all (c) .then (function () {g (d )}, E): g (! 0)} função f (a, b) {k === h. $$ currentValidationRunId &&
h. $ setValidity (a, b)} função g (a) {k === h. $$ currentValidationRunId && d (a)} this. $$ currentValidationRunId ++; var k = this. $$ currentValidationRunId, h = this; (function () {var a = h. $$ parserName; if (z (h. $$ parserValid)) f (a, null); senão retorna h. $$ parserValid || (r (h. $ validadores, função (a , b) {f (b, nulo)}), r (h. $ asyncValidators, função (a, b) {f (b, nulo)})), f (a, h. $$ parserValid), h. $ parserValid; return! 0}) ()? c ()? e (): g (! 1): g (! 1)}, $ commitViewValue: function () {var a = this. $ viewValue; this. $$ timeout.cancel (this. $$ pendingDebounce); if (this. $$ lastCommittedViewValue! ==
a || "" === a && this. $$ hasNativeValidators) this. $$ updateEmptyClasses (a), this. $$ lastCommittedViewValue = a, this. $ pristine && this. $ setDirty (), this. $$ parseAndValidate ()}, $$ parseAndValidate: function () {var a = this. $$ lastCommittedViewValue, b = this; this. $$ parserValid = z (a)? void 0:! 0; this. $ setValidity (this. $$ parserName, null ); this. $$ parserName = "parse"; if (this. $$ parserValid) for (var d = 0; d <this. $ parsers.length; d ++) if (a = this. $ parsers [d] ( a), z (a)) {this. $$ parserValid =! 1; break} X (this. $ modelValue) && (this. $ modelValue = this. $$ ngModelGet (this. $$ scope));
var c = this. $ modelValue, e = this. $ options.getOption ("allowInvalid"); this. $$ rawModelValue = a; e && (this. $ modelValue = a, b. $ modelValue! == c && b. $$ writeModelToScope ()); this. $$ runValidators (a, this. $$ lastCommittedViewValue, função (d) {e || (b. $ modelValue = d? a: void 0, b. $ modelValue! == c && b. $ $ writeModelToScope ())})}, $$ writeModelToScope: function () {this. $$ ngModelSet (this. $$ scope, this. $ modelValue); r (this. $ viewChangeListeners, function (a) {try {a ()} catch (b) {this. $$ exceptionHandler (b)}}, this)}, $ setViewValue: function (a, b) {this. $ viewValue =
$ debugViewViewValueCommit (b)}, $$ debounceViewValueCommit (b)}, $$ debounceViewValueCommit: function (a) {var b = this. $ options.getOption ("debounce"); W (b [a])? b = b [a]: W (b ["padrão"]) && - 1 === isso. $ options.getOption ("updateOn"). indexOf (a)? b = b ["padrão "]: W (b [" * "]) && (b = b [" * "]); this. $$ timeout.cancel (this. $$ pendingDebounce); var d = this; 0 <b? This. $$ pendingDebounce = this. $$ timeout (function () {d. $ commitViewValue ()}, b): this. $$ rootScope. $$ phase? this. $ commitViewValue (): this. $$ scope. $ apply (function () {d. $ commitViewValue ()})},
$ overrideModelOptions: function (a) {this. $ options = this. $ options.createChild (a); this. $$ setUpdateOnEvents ()}, $ processModelValue: function () {var a = this. $$ format (); Este $ viewValue! == a && (este. $$ updateEmptyClasses (a), este. $ viewValue = este. $$ lastCommittedViewValue = a, este. $ render (), este. $$ runValidators (este. $ modelValue, este . $ viewValue, E))}, $$ format: function () {for (var a = this. $ formatadores, b = a.length, d = this. $ modelValue; b -;) d = a [b ] (d); return d}, $$ setModelValue: function (a) {this. $ modelValue = this. $$ rawModelValue = a; this. $$ parserValid =
void 0; this. $ processModelValue ()}, $$ setUpdateOnEvents: function () {this. $$ updateEvents && this. $$ element.off (this. $$ updateEvents, this. $$ updateEventHandler); if (this. $$ updateEvents = this. $ options.getOption ("updateOn")) this. $$ element.on (this. $$ updateEvents, this. $$ updateEventHandler)}, $$ updateEventHandler: function (a) {this. $$ debounceViewValueCommit (a && a.type)}}; ae ({clazz: Rb, set: function (a, b) {a [b] =! 0}, desmarcado: function (a, b) {delete a [b]}}) ; var pf = ["$ rootScope", função (a) {return {restrita: "A", requer: ["ngModel",
"^? form", "^? ngModelOptions"], controlador: Rb, prioridade: 1, compilação: function (b) {b.addClass (Za) .addClass ("ng-intocado"). addClass (mb); return {pre: function (a, b, e, f) {var g = f [0]; b = f [1] || g. $$ parentForm; se (f = f [2]) g. $ options = f. $ options; g. $$ initGetterSetters (); b. $ addControl (g); e. $ observe ("nome", função (a) {g. $ name! == a && g. $$ parentForm. $$ renameControl (g, a)}); a. $ on ("$ destroy", function () {g. $$ parentForm. $ removeControl (g)})}, post: function (b, c, e, f) {função g () {k. $ setTouched ()} var k = f [0]; k. $$ setUpdateOnEvents (); c.on ("desfoque",
function () {k. $ tocou || (fase a. $$? b. $ evalAsync (g): b. $ apply (g))})}}}}}], Sb, wh = / (\ s + | ^) default (\ s + | $) /; Lc.prototype = {getOption: function (a) {retorna isso. $$ opções [a]}, createChild: function (a) {var b =! 1; a = S ({}, a); r (a, função (d, c) {"$ herdar" === d? "*" === c? B =! 0: (a [c] = this. $ $ options [c], "updateOn" === c && (a.updateOnDefault = this. $$ options.updateOnDefault)): "updateOn" === c && (a.updateOnDefault =! 1, a [c] = U ( d.replace (wh, function () {a.updateOnDefault =! 0; return ""})))}, this); b && (exclua a ["*"], ge (a, this. $$ opções)) ; ge (a, Sb. $$ opções);
return new Lc (a)}}; Sb = new Lc ({updateOn: "", updateOnDefault:! 0, debounce: 0, getterSetter:! 1, allowInvalid:! 1, fuso horário: null}); var tf = function ( ) {function a (a, d) {this. $$ attrs = a; this. $$ scope = d} a. $ inject = ["$ attrs", "$ scope"]; a.prototype = {$ onInit : function () {var a = this.parentCtrl? this.parentCtrl. $ options: Sb, d = this. $$ scope. $ eval (this. $$ attrs.ngModelOptions); this. $ options = a.createChild ( d)}}; return {restringir: "A", prioridade: 10, exigir: {parentCtrl: "? ^^ ngModelOptions"}, bindToController:! 0, controller: a}}, df = Ra ({terminal:! 0 ,
prioridade: 1E3}), xh = F ("ngOptions"), yh = / ^ \ s * ([\ s \ S] +?) (?: \ s + como \ s + ([\ s \ S] +? ))? (?: \ s + grupo \ s + por \ s + ([\ s \ S] +?))? (?: \ s + desativar \ s + quando \ s + ([\ s \ S] +? ))? \ s + para \ s + (?: ([$ \ w] [$ \ w] *) | (?: \ (\ s * ([$ \ w] [$ \ w] *) \ s * , \ s * ([$ \ w] [$ \ w] *) \ s * \))) \ s + em \ s + ([\ s \ S] +?) (?: \ s + faixa \ s + por \ s + ([\ s \ S] +?))? $ /, nf = ["$ compile", "$ document", "$ parse", função (a, b, d) {função c (a, b, c) {function e (a, b, c, d, f) {this.selectValue = a; this.viewValue = b; this.label = c; this.group = d; this.disabled = f} função f (a) {var b; se (! r && ya (a)) b = a; else {b = []; para (var c em a) a.hasOwnProperty (c) &&
"$"! == c.charAt (0) && b.push (c)} retornar b} var p = a.match (yh); se (! p) jogar xh ("iexp", a, za (b) ); var n = p [5] || p [7], r = p [6]; a = / as /.test(p[0})&&p[1✨;var q = p [9]; b = d (p [2]? p [1]: n); var t = a && d (a) || b, w = q && d (q), v = q? função (a, b) {retorno w (c, b)}: função (a) {retornar La (a)}, x = função (a, b) {retornar v (a, A (a, b))}, z = d (p [2] || p [1]), y = d (p [3] || ""), J = d (p [4] || ""), I = d (p [8]), B = {}, A = r? função (a, b) {B [r] = b; B [n] = a; retornar B}: função (a) {B [n] = a; retornar B}; retornar {trackBy: q, getTrackByValue : x, getWatchables: d (I, função (a) {var b = []; a = a || []; for (var d =
f (a), e = comprimento d, g = 0; g <e; g ++) {var k = a === d? g: d [g], l = a [k], k = A (l , k), l = v (l, k); b.push (l); if (p [2] || p [1]) l = z (c, k), b.push (l); p [4] && (k = J (c, k), b.push (k))} retorno b}), getOptions: function () {for (var a = [], b = {}, d = I ( c) || ​​[], g = f (d), k = comprimento g, n = 0; n <k; n ++) {var p = d === g? n: g [n], r = A (d [p], p), s = t (c, r), p = v (s, r), w = z (c, r), B = y (c, r), r = J (c , r), s = new e (p, s, w, B, r); a.push (s); b [p] = s} retornar {itens: a, selectValueMap: b, getOptionFromViewValue: function (a) {return b [x (a)]}, getViewValueFromOption: function (a) {return q? Ia (a.viewValue): a.viewValue}}}}}
var e = C.document.createElement ("opção"), f = C.document.createElement ("optgroup"); retornar {restringir: "A", terminal:! 0, exigir: ["selecionar", "ngModel" ], link: {pre: function (a, b, c, d) {d [0] .registerOption = E}, post: function (d, k, h, l) {função m (a) {var b = (a = v.getOptionFromViewValue (a)) && a.element; b &&! b.selected && (b.selected =! 0); retornar a} função p (a, b) {a.element = b; b.disabled = a .disabled; a.label! == b.label && (b.label = a.label, b.textContent = a.label); b.value = a.selectValue} var n = l [0], q = l [ 1], z = h.multiple; l = 0; for (var t = k.children (),
B = comprimento.l; l <B; l ++) if ("" === t [l] .valor) {n.hasEmptyOption =! 0; n.emptyOption = t.q (l); break} k.empty (); l = !! n.emptyOption; x (e.cloneNode (! 1)). val ("?"); var v, A = c (h.ngOptions, k, d), C = b [0 ] .createDocumentFragment (); n.generateUnknownOptionValue = function (a) {return "?"}; z? (n.writeValue = function (a) {if (v) {var b = a && a.map (m) || [ ]; v.items.forEach (function (a) {a.element.selected && - 1 === Array.prototype.indexOf.call (b, a) && (a.element.selected =! 1)})}} , n.readValue = function () {var a = k.val () || [], b = []; r (a, função (a) {(a = v.selectValueMap [a]) &&
! a.disabled && b.push (v.getViewValueFromOption (a))}); return b}, A.trackBy && d. $ watchCollection (function () {if (H (q. $ viewValue)) retorna q. $ viewValue.map ( function (a) {return A.getTrackByValue (a)})}, function () {q. $ render ()})) :( n.writeValue = function (a) {if (v) {var b = k [ 0] .opções [k [0] .selectedIndex], c = v.getOptionFromViewValue (a); b && b.removeAttribute ("selected"); c? (K [0] .value! == c.selectValue && (n.removeUnknownOption (), k [0] .valor = c.selectValue, c.element.selected =! 0), c.element.setAttribute ("selected", "selected")): n.selectUnknownOrEmptyOption (a)}},
n.readValue = function () {var a = v.selectValueMap [k.val ()]; retorna um &&! a.disabled? (n.unselectEmptyOption (), n.removeUnknownOption (), v.getViewValueFromOption (a)): null}, A.trackBy && d. $ watch (function () {retorna A.getTrackByValue (q. $ viewValue)}, função () {q. $ render ()})); l && (a (n.emptyOption) (d ), k.prepend (n.emptyOption), 8 === n.emptyOption [0] .nodeType? (n.hasEmptyOption =! 1, n.registerOption = function (a, b) {"" === b. val () && (n.hasEmptyOption =! 0, n.emptyOption = b, n.emptyOption.removeClass ("ng-scope"), q. $ render (), b.on ("$ destroy",
function () {var a = n. $ isEmptyOptionSelected (); n.hasEmptyOption =! 1; n.emptyOption = void 0; a && q. $ render ()}))}): n.emptyOption.removeClass ("ng-scope ")); d. $ watchCollection (A.getWatchables, function () {var a = v && n.readValue (); if (v) para (var b = v.items.length-1; 0 <= b; b- -) {var c = v.items [b]; w (c.group)? Fb (c.element.parentNode): Fb (c.element)} v = A.getOptions (); var d = {}; v.items.forEach (function (a) {var b; if (w (a.group)) {b = d [a.group]; b || (b = f.cloneNode (! 1), C.appendChild (b), b.label = null === a.group?"null":a.group,d[a.group}=b);
var c = e.cloneNode (! 1); b.appendChild (c); p (a, c)} else b = e.cloneNode (! 1), C.appendChild (b), p (a, b)} ); k [0] .appendChild (C); q. $ render (); q. $ isEmpty (a) || (b = n.readValue (), (A.trackBy || z? va (a, b ): a === b) || (q. $ setViewValue (b), q. $ render ()))})}}}}]], ef = ["$ locale", "$ interpolate", "$ log ", função (a, b, d) {var c = / {} / g, e = / ^ quando (Menos)? (. +) $ /; retornar {link: função (f, g, k) { função h (a) {g.text (a || "")} var l = k.count, m = k. $ attr.when && g.attr (k. $ attr.when), p = k.offset || 0, n = f. $ Eval (m) || {}, q = {}, w = b.startSymbol (), t = b.endSymbol (), x = w + l + "-" +
p + t, v = ca.noop, A; r (k, função (a, b) {var c = e.exec (b); c && (c = (c [1]? "-": "") + K (c [2]), n [c] = g.atr (k. $ Attr [b]))}); r (n, função (a, d) {q [d] = b (a. substitua (c, x))}); f. $ watch (l, função (b) {var c = parseFloat (b), e = X (c); e || c em n || (c = a. pluralCat (cp)); c === A || e && X (A) || (v (), e = q [c], z (e)? (null! = b && d.debug ("ngPluralize: nenhuma regra definida para '"+ c +"' em "+ m), v = E, h ()): v = f. $ watch (e, h), A = c)})}}}], qe = F (" ngRef "), ff = [" $ parse ", função (a) {retornar {prioridade: -1, restringir:" A ", compilar: função (b, d) {var c = wa (ua (b)), e = a (d.ngRef), f = atribuição e ||
function () {throw qe ("nonassign", d.ngRef);}; função de retorno (a, b, h) {var l; if (h.hasOwnProperty ("ngRefRead")) if ("$ element" == = h.ngRefRead) l = b; else {if (l = b.data ("$" + h.ngRefRead + "Controller") ,! l) throw qe ("noctrl", h.ngRefRead, d.ngRef); } else l = b.data ("$" + c + "Controller"); l = l || b; f (a, l); b.on ("$ destroy", function () {e (a) = == l && f (a, null)})}}}]], gf = ["$ parse", "$ animate", "$ compile", função (a, b, d) {var c = F ("ngRepeat "), e = função (a, b, c, d, e, f, g) {a [c] = d; e && (a [e] = f); a. $ index = b; a. $ first = 0 === b; a. $ Last = b === g-1; a. $ Middle =! (A. $ First ||
a. $ last); a. $ odd =! (a. $ par = 0 === (b & 1))}, f = função (a, b, c) {retorna La (c)}, g = função ( a, b) {return b}; return {strict: "A", multiElement:! 0, transclude: "element", prioridade: 1E3, terminal:! 0, $$ tlb:! 0, compile: function (k, h) {var l = h.ngRepeat, m = d. $$ createComment ("end ngRepeat", l), p = l.match (/ ^ \ s * ([\ s \ S] +?) \ s + in \ s + ([\ s \ S] +?) (?: \ s + as \ s + ([\ s \ S] +?))? (?: \ s + trilha \ s + por \ s + ([\ s \ S] +?))? \ s * $ /); se (! p) joga c ("iexp", l); var n = p [1], q = p [2], w = p [ 3], t = p [4], p = n.match (/ ^ (?: (\ S * [$ \ w] +) | \ (\ s * ([$ \ w] +) \ s *, \ s * ([$ \ w] +) \ s * \)) $ /); se (! p) jogar c ("iidexp",
n); var x = p [3] || p [1], v = p [2]; if (w && (! / ^ [$ a-zA-Z _] [$ a-zA-Z0-9 _] * $ /. test (w) || / ^ (null | undefined | this | \ $ index | \ $ first | \ $ middle | \ $ last | \ $ even | \ $ odd | \ $ parent | \ $ root | \ $ id) $ /. test (w))) joga c ("badident", w); var z; if (t) {var A = {$ id: La}, y = a (t); z = função (a, b, c, d) {v && (A [v] = b); A [x] = c; A. $ index = d; retorno y (a, A)}} função de retorno (a, d , h, k, n) {var p = T (); a. $ watchCollection (q, função (h) {var k, q, t = d [0], s, y = T (), B, C , E, D, H, F, K; w && (a [w] = h); se (ya (h)) H = h, q = z || f; senão para (K em q = z || g , H = [], h) ta.call (h, K) && "$"! == K.charAt (0) && H.push (K);
B = comprimento H.; K = matriz (B); para (k = 0; k <B; k ++) se (C = h === H? K: H [k], E = h [C], D = q (a, C, E, k), p [D]) F = p [D], exclua p [D], y [D] = F, K [k] = F; caso contrário, {if (y [ D]) lança r (K, função (a) {a && a.scope && (p [a.id] = a)}), c ("dupes", l, D, E); K [k] = {id: D, escopo: vazio 0, clone: ​​vazio 0}; y [D] =! 0} A && (A [x] = vazio 0); para (s em p) {F = p [s]; D = tb ( F.clone); b.leave (D); if (D [0] .parentNode) para (k = 0, q = D.length; k <q; k ++) D [k]. $$ NG_REMOVED =! 0 ; F.scope. $ Destroy ()} para (k = 0; k <B; k ++) if (C = h === H? K: H [k], E = h [C], F = K [ k], F.scope) {s = t; do s = s.nextSibling; while (s && s. $$ NG_REMOVED); F.clone [0]! ==
s && b.move (tb (F.clone), null, t); t = F.clone [F.clone.length-1]; e (F.scope, k, x, E, v, C, B)} else n (function (a, c) {F.scope = c; var d = m.cloneNode (! 1); a [a.length ++] = d; b.enter (a, null, t); t = d ; F.clone = a; y [F.id] = F; e (F.scope, k, x, E, v, C, B)}); p = y})}}}}], hf = ["$ animate", função (a) {return {restrita: "A", multiElement:! 0, link: function (b, d, c) {b. $ watch (c.ngShow, função (b) {a [b? "removeClass": "addClass"] (d, "ng-hide", {tempClasses: "ng-hide-animate"})})}}}], $ e = ["$ animate", função ( a) {return {restringir: "A", multiElement:! 0, link: function (b,
d, c) {b. $ watch (c.ngHide, função (b) {a [b? "addClass": "removeClass"] (d, "ng-hide", {tempClasses: "ng-hide-animate" })})}}}], jf = Ra (função (a, b, d) {a. $ watchCollection (d.ngStyle, função (a, d) {d && a! == d && r (d, função (a, c) {b.css (c, "")}); a && b.css (a)})}), kf = ["$ animate", "$ compile", função (a, b) {return {exigem: "ngSwitch", controller: ["$ scope", function () {this.cases = {}}], link: function (d, c, e, f) {var g = [], k = [], h = [], l = [], m = função (a, b) {função de retorno (c) {! 1! == c && a.splice (b, 1)}}; d. $ watch (e.ngSwitch || na função (c) {for (var d,
e; h.length;) a.cancel (h.pop ()); d = 0; para (e = l.length; d <e; ++ d) {var q = tb (k [d] .clone ); l [d]. $ destroy (); (h [d] = a.leave (q)). done (m (h, d))} k.length = 0; l.length = 0; (g = f.cases ["!" + c] || f.cases ["?"]) && r (g, função (c) {c.transclude (função (d, e) {l.push (e); var f = c.element; d [d.length ++] = b. $$ createComment ("end ngSwitchWhen"); k.push ({clone: ​​d}); a.enter (d, f.parent (), f) })})})}}]], lf = Ra ({transclude: "elemento", prioridade: 1200, requer: "^ ngSwitch", multiElement:! 0, link: function (a, b, d, c, e) {a = d.ngSwitchWhen.split (d.ngSwitchWhenSeparator) .sort (). filter (function (a,
b, c) {return c [b-1]! == a}); r (a, função (a) {c.cases ["!" + a] = c.cases ["!" + a] | | []; c.cases ["!" + a] .push ({transclude: e, elemento: b})})}}), mf = Ra ({transclude: "elemento", prioridade: 1200, exija: "^ ngSwitch", multiElement:! 0, link: function (a, b, d, c, e) {c.cases ["?"] = c.cases ["?"] || []; c.cases ["?"]. push ({transclude: e, elemento: b})}}), zh = F ("ngTransclude"), de = ["$ compile", função (a) {return {strict: "EAC ", compile: function (b) {var d = a (b.contents ()); b.empty (); função de retorno (a, b, f, g, k) {function h () {d (a, função (a) {b.append (a)})} if (! k) throw zh ("órfão",
za (b)); f.ngTransclude === f. $ attr.ngTransclude && (f.ngTransclude = ""); f = f.ngTransclude || f.ngTranscludeSlot; k (função (a, c) {var d; if (d = a.length) a: {d = 0; for (var f = a.length; d <f; d ++) {var g = a [d]; if (g.nodeType! == Pa || g.nodeValue.trim ()) {d =! 0; quebra a}} d = nulo 0} d? b.append (a) :( h (), c. $ destroy ())}, nulo, f) ; f &&! k.isSlotFilled (f) && h ()}}}}], Oe = ["$ templateCache", função (a) {return {restringir: "E", terminal:! 0, compilar: function (b, d) {"text / ng-template" === d.type && a.put (d.id, b [0] .text)}}}], Ah = {$ setViewValue: E, $ render: E}, Bh = ["$ elemento",
"$ scope", function (a, b) {function d () {g || (g =! 0, b. $$ postDigest (function () {g =! 1; e.ngModelCtrl. $ render ()} ))} função c (a) {k || (k =! 0, b. $$ postDigest (função () {b. $$ destruído || (k =! 1, e.ngModelCtrl. $ setViewValue (e. readValue ()), um && e.ngModelCtrl. $ render ())}))} var e = isso, f = novo Hb; e.selectValueMap = {}; e.ngModelCtrl = Ah; e.multiple =! 1; e. unknownOption = x (C.document.createElement ("opção")); e.hasEmptyOption =! 1; e.emptyOption = void 0; e.renderUnknownOption = function (b) {b = e.generateUnknownOptionValue (b); e. unknownOption.val (b);
a.prepend (e.unknownOption); Oa (e.unknownOption,! 0); a.val (b)}; e.updateUnknownOption = function (b) {b = e.generateUnknownOptionValue (b); e.unknownOption.val (b); Oa (e.unknownOption,! 0); a.val (b)}; e.generateUnknownOptionValue = function (a) {return "?" + La (a) + "?"}; e.removeUnknownOption = function () {e.unknownOption.parent () && e.unknownOption.remove ()}; e.selectEmptyOption = function () {e.emptyOption && (a.val (""), Oa (e.emptyOption,! 0)) }; e.unselectEmptyOption = function () {e.hasEmptyOption && Oa (e.emptyOption,! 1)}; b. $ on ("$ destroy",
function () {e.renderUnknownOption = E}); e.readValue = function () {var b = a.val (), b = b em e.selectValueMap? e.selectValueMap [b]: b; return e.hasOption (b)? b: null}; e.writeValue = function (b) {var c = a [0] .opções [a [0] .Index selecionado); c && Oa (x (c) ,! 1); e.hasOption (b)? (e.removeUnknownOption (), c = La (b), a.val (c em e.selectValueMap? c: b), Oa (x (a [0] .opções [a [0] .selectedIndex ]) ,! 0)): e.selectUnknownOrEmptyOption (b)}; e.addOption = function (a, b) {if (8! == b [0] .nodeType) {Ja (a, '"option value" '); "" === a && (e.hasEmptyOption =! 0, e.emptyOption =
b); var c = f.get (a) || 0; f.set (a, c + 1); d ()}}; e.removeOption = função (a) {var b = f.get (a ); b && (1 === b? (f.delete (a), "" === a && (e.hasEmptyOption =! 1, e.emptyOption = void 0)): f.set (a, b-1 ))}; e.hasOption = function (a) {return !! f.get (a)}; e. $ hasEmptyOption = function () {return e.hasEmptyOption}; e. $ isUnknownOptionSelected = function () {return a [0] .opções [0] === e.unknownOption [0]}; e. $ IsEmptyOptionSelected = function () {retornar e.hasEmptyOption && a [0] .opções [a [0] .selectedIndex] === e. emptyOption [0]}; e.selectUnknownOrEmptyOption = function (a) {null ==
a && e.emptyOption? (e.removeUnknownOption (), e.selectEmptyOption ()): e.unknownOption.parent (). length? e.updateUnknownOption (a): e.renderUnknownOption (a)}; var g =! 1, k =! 1; e.registerOption = função (a, b, f, g, k) {if (f. $ Attr.ngValue) {var q, r; f. $ Observe ("valor", função (a) { var d, f = b.prop ("selecionado"); w (r) && (e.removeOption (q), exclua e.selectValueMap [r], d =! 0); r = La (a); q = a; e.selectValueMap [r] = a; e.addOption (a, b); b.attr ("valor", r); d && f && c ()})} else g? f. $ observe ("value", function (a) {e.readValue (); var d, f = b.prop ("selecionado");
w (q) && (e.removeOption (q), d =! 0); q = a; e.addOption (a, b); d && f && c ()}): k? a. $ watch (k, function (a , d) {f. $ set ("valor", a); var g = b.prop ("selecionado"); d! == a && e.removeOption (d); e.addOption (a, b); d && g && c ( )}): e.addOption (f.value, b); f. $ observe ("desativado", função (a) {if ("true" === a || a && b.prop ("selected")) e .multiple? c (! 0) :( e.ngModelCtrl. $ setViewValue (null), e.ngModelCtrl. $ render ())}); b.on ("$ destroy", function () {var a = e. readValue (), b = f.value; e.removeOption (b); d (); (e.multiple && a && - 1! == a.indexOf (b) || a === b) && c (! 0)} )}}], Pe = function () {return {strict: "E",
exigir: ["selecionar", "? ngModel"], controlador: Bh, prioridade: 1, link: {pre: function (a, b, d, c) {var e = c [0], f = c [1 ]; if (f) {if (e.ngModelCtrl = f, b.on ("alterar", função () {e.removeUnknownOption (); a. $ apply (function () {f. $ setViewValue (e.readValue ())})}), d.multiple) {e.multiple =! 0; e.readValue = function () {var a = []; r (b.find ("opção"), função (b) { b.selected &&! b.disabled && (b = valor b, valor a.push (b em e.selectValueMap? e.selectValueMap? e.selectValueMap [b]: b))}); retornar a}; e.writeValue = function (a) { r (b.find ("opção"), função (b) {var c = !! a && (- 1! == Array.prototype.indexOf.call (a,
b.value) || -1! == Array.prototype.indexOf.call (a, e.selectValueMap [b.value])); c! == b.selected && Oa (x (b), c)})} ; var g, k = NaN; a. $ watch (function () {k! == f. $ viewValue || va (g, f. $ viewValue) || (g = ja (f. $ viewValue), f . $ render ()); k = f. $ viewValue}); f. $ isEmpty = função (a) {return! a || 0 === comprimento.}}} else e.registerOption = E}, post : função (a, b, d, c) {var e = c [1]; se (e) {var f = c [0]; e. $ render = function () {f.writeValue (e. $ viewValue )}}}}}}, Qe = ["$ interpolar", função (a) {retornar {restringir: "E", prioridade: 100, compilar: função (b, d) {var c, e; w (d .ngValue) ||
(w (valor d))? c = a (valor d,! 0) :( e = a (b.text () ,! 0)) || d. $ set ("valor", b.text ( )));; função de retorno (a, b, d) {var h = b.parent (); (h = h.data ("$ selectController") || h.parent (). data ("$ selectController") ) && h.registerOption (a, b, d, c, e)}}}], $ c = ["$ parse", função (a) {return {restrita: "A", requer: "? ngModel", link: função (b, d, c, e) {se (e) {var f = c.hasOwnProperty ("required") || a (c.ngRequired) (b); c.ngRequired || (c.required =! 0); e. $ Validators.required = function (a, b) {return! F ||! E. $ IsEmpty (b)}; c. $ Observe ("obrigatório", função (a) {f! == a && (f =
a, e. $ validate ())})}}}], Zc = ["$ parse", função (a) {return {restringir: "A", exigir: "? ngModel", compilar: function (b , d) {var c, e; d.ngPadrão && (c = d.ngPadrão, e = "/" === d.ngPadrão.charAt (0) && ie.test (d.ngPadrão)? function () {return d .ngPattern}: a (d.ngPattern)); função de retorno (a, b, d, h) {if (h) {var l = d.pattern; d.ngPattern? l = e (a): c = d .padrão; var m = ele (l, c, b); d. $ observe ("padrão", função (a) {var d = m; m = ele (a, c, b); (d && d.toString ( ))! == (m && m.toString ()) && h. $ validate ()}); h. $ validators.pattern = função (a, b) {retornar h. $ isEmpty (b) ||
z (m) || m.test (b)}}}}}], bd = ["$ parse", função (a) {return {restrita: "A", requer: "? ngModel", link: função (b, d, c, e) {if (e) {var f = c.maxlength || a (c.ngMaxlength) (b), g = Tb (f); c. $ observe ("maxlength", (a) (f) == a && (g = Tb (a), f = a, e. $ validate ())}); e. $ validators.maxlength = função (a, b) {return 0> g || e. $ isEmpty (b) || b.length <= g}}}}}], ad = ["$ parse", função (a) {return {strict: "A", exigem: "? ngModel ", link: função (b, d, c, e) {se (e) {var f = c.minlength || a (c.ngMinlength) (b), g = Tb (f) || -1; c . $ observe ("minlength", função (a) {f! ==
a && (g = Tb (a) || -1, f = a, e. $ validate ())}); e. $ validators.minlength = function (a, b) {return e. $ isEmpty (b) | | b.length> = g}}}}}]; C.angular.bootstrap? C.console && console.log ("AVISO: Tentou carregar o AngularJS mais de uma vez.") :( Fe (), Je (ca), ca.module ("ngLocale", [], ["$ allow", function (a) {function b (a) {a + = ""; var b = a.indexOf ("."); return-1 == b? 0: a.length-b-1} a.value ("$ locale", {DATETIME_FORMATS: {AMPMS: ["AM", "PM"], DAY: "Domingo segunda terça quarta quinta quinta sexta sábado" .split (""), ERANAMES: ["Antes de Cristo", "Anno Domini"],
ERAS: ["BC", "AD"], FIRSTDAYOFWEEK: 6, MÊS: "janeiro fevereiro março abril maio junho julho agosto setembro outubro novembro dezembro" .split (""), SHORTDAY: "dom seg ter qua qui sex sáb" .split (""), CURTO: "Jan fev mar abr maio jun jul ago set out nov dez" .split (""), STANDALONEMONTH: "janeiro fevereiro março abril maio junho julho agosto setembro outubro outubro novembro dezembro" .split (" "), WEEKENDRANGE: [5,6], fullDate:" EEEE, MMMM d, y ", longDate:" MMMM d, y ", meio:" MMM d, yh: mm: ss a ", mediumDate:" MMM d , y ", mediumTime:" h: mm: ss a ",
"short": "M / d / aa h: mm a", shortDate: "M / d / aa", shortTime: "h: mm a"}, NUMBER_FORMATS: {CURRENCY_SYM: "$", DECIMAL_SEP: "." , GROUP_SEP: ",", PATTERNS: [{gSize: 3, lgSize: 3, maxFrac: 3, minFrac: 0, minInt: 1, negPre: "-", negSuf: "", posPre: "", posSuf: " "} {gSize: 3, lgSize: 3, maxFrac: 2, minFrac: 2, minInt: 1, negPre:" - \ u00a4 ", negSuf:" ", posPre:" \ u00a4 ", posSuf:" "}] }, id: "en-us", localeID: "en_US", pluralCat: function (a, c) {var e = a | 0, f = c; void 0 === f && (f = Math.min (b (a), 3)); Math.pow (10, f); return 1 == e && 0 == f? "one": "other"}})}])), x (function () {Ae (C. documento,
Uc)}))}) (window) ;! window.angular. $$ csp (). NoInlineStyle && window.angular.element (document.head) .prepend ('<style type = "text / css"> @ charset "UTF -8 "; [ng \\: manto], [ng-manto], [data-ng-manto], [x-ng-manto],. Ng-manto, .x-ng-manto, .ng-hide : not (.ng-hide-animate) {exibição: nenhuma! importante;} ng \\: formulário {exibição: bloco;}. ng-animação-calço {visibilidade: oculta;}. ng-âncora {posição: absoluta; } </style> ');
// # sourceMappingURL = angular.min.js.map